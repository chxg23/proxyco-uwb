 /*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @file dw3000_mac.c
 * @author UWB Core <uwbcore@gmail.com>
 * @date 2018
 * @brief Mac initialization
 *
 * @details This is the mac base class which utilizes the functions to do the configurations related to mac layer based on dependencies.
 *
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>
#include <os/os.h>
#include <hal/hal_spi.h>
#include <hal/hal_gpio.h>
#include <stats/stats.h>

#include <uwb/uwb_encryption.h>

#include <dpl/dpl_cputime.h>
#include <uwb/uwb_ftypes.h>
#include <dw3000-c0/dw3000_regs.h>
#include <dw3000-c0/dw3000_dev.h>
#include <dw3000-c0/dw3000_hal.h>
#include <dw3000-c0/dw3000_phy.h>
#include <dw3000-c0/dw3000_stats.h>
#include <dw3000-c0/dw3000_mac.h>

#if MYNEWT_VAL(DW3000_MAC_STATS)
STATS_NAME_START(dw3000_mac_stat_section)
    STATS_NAME(dw3000_mac_stat_section, tx_bytes)
    STATS_NAME(dw3000_mac_stat_section, rx_bytes)
    STATS_NAME(dw3000_mac_stat_section, DFR_cnt)
    STATS_NAME(dw3000_mac_stat_section, RTO_cnt)
    STATS_NAME(dw3000_mac_stat_section, ROV_err)
    STATS_NAME(dw3000_mac_stat_section, TFG_cnt)
    STATS_NAME(dw3000_mac_stat_section, LDE_err)
    STATS_NAME(dw3000_mac_stat_section, RX_err)
    STATS_NAME(dw3000_mac_stat_section, TXBUF_err)
    STATS_NAME(dw3000_mac_stat_section, FCMD_err)
    STATS_NAME(dw3000_mac_stat_section, SPI_err)
    STATS_NAME(dw3000_mac_stat_section, STSPream_err)
    STATS_NAME(dw3000_mac_stat_section, PLL_LL_err)
    STATS_NAME(dw3000_mac_stat_section, empty_irq)
STATS_NAME_END(dw3000_mac_stat_section)

#define MAC_STATS_INC(__X) STATS_INC(inst->stat, __X)
#define MAC_STATS_INCN(__X, __Y) STATS_INCN(inst->stat, __X, __Y)
#else
#define MAC_STATS_INC(__X) {}
#define MAC_STATS_INCN(__X, __Y) {}
#endif


static void dw3000_interrupt_ev_cb(struct dpl_event *ev);
static void dw3000_irq(void *arg);
static int dwt_pgf_cal(struct _dw3000_dev_instance_t * inst, int ldoen);
static int dwt_run_pgfcal(struct _dw3000_dev_instance_t * inst);

//#define DIAGMSG(s,u) printf(s,u)
#ifndef DIAGMSG
#define DIAGMSG(s,u)
#endif

/* STS Minimum Threshold (STS_MNTH) needs to be adjusted with changing STS length.
To adjust the STS_MNTH following formula can be used: STS_MNTH = SQRT(X/Y)*default_STS_MNTH
default_STS_MNTH is 0x10
X is the length of the STS in units of 8 (i.e. 8 for 64 length, 16 for 128 length etc.)
Y is either 8 or 16, 8 when no PDOA or PDOA mode 1 and 16 for PDOA mode 3

The API does not use the formula and the STS_MNTH value is derived from approximation formula as given by get_sts_mnth()
function. The API here supports STS lengths as listed in: dwt_sts_lengths_e enum, which are: 32, 64, 128, 256, 512, 1024, 2048
The enum value is used as the index into sts_length_factors array. The array has values which are generated by:
val = SQRT(stsLength/16)*2048
*/
#define SQRT_FACTOR             181 /*Factor of sqrt(2) for calculation*/
#define STS_LEN_SUPPORTED       7   /*The supported STS length options*/
#define SQRT_SHIFT_VAL          7
#define SHIFT_VALUE             11
#define MOD_VALUE               2048
#define HALF_MOD                (MOD_VALUE>>1)

static const uint16_t sts_length_factors[STS_LEN_SUPPORTED]=
{
    1024,1448,2048,2896,4096,5793,8192
};

static uint16_t
get_sts_mnth (uint16_t cipher, uint8_t threshold, uint8_t shift_val)
{
    uint32_t  value;
    uint16_t  mod_val;

    value = cipher* (uint32_t)threshold;
    if (shift_val == 3)
    {
        value *= SQRT_FACTOR;//Factor to sqrt(2)
        value >>= SQRT_SHIFT_VAL;
    }

    mod_val = value % MOD_VALUE+ HALF_MOD;
    value >>= SHIFT_VALUE;
    /* Check if modulo greater than MOD_VALUE, if yes add 1 */
    if (mod_val >= MOD_VALUE)
        value += 1;

    return (uint16_t)value;
}


/**
 * API to configure the mac layer in dw3000
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param config   Pointer to struct uwb_dev_config.
 * @return struct uwb_dev_status
 *
 */
#define CIA_MANUALLOWERBOUND_TH_64  (0x10)
#define CIA_MANUALLOWERBOUND_TH_16  (0x06)

struct uwb_dev_status
dw3000_mac_config(struct _dw3000_dev_instance_t * inst, struct uwb_dev_config * config)
{
    uint8_t chan, scp, sts_len;
    uint32_t reg32, rxauto, phrMode;
    uint8_t xtal_trim;
    int rc, timeout;
    int preamble_len;

    if (!inst->uwb_dev.status.initialized) {
        printf("%s:%d: ERROR, device not initialized\n", __func__, __LINE__);
        return inst->uwb_dev.status;
    }

    if (config == NULL) {
        config = &inst->uwb_dev.config;
    } else {
        memcpy(&inst->uwb_dev.config, config, sizeof(struct uwb_dev_config));
    }

    /* If there's a valid xtalTrim value use it, otherwise set default 0x2e */
    xtal_trim = (uint16_t)_dw3000_otp_read(inst, OTP_XTRIM_ADDRESS);
    if (xtal_trim == 0) {
        /* No OTP value set, check config for valid value otherwise set default */
        xtal_trim = (config->rx.xtalTrim == 0xff) ? 0x2e : config->rx.xtalTrim;
    } else if (config->rx.xtalTrim != 0xff) {
        /* OTP value set but config overrides it */
        xtal_trim = config->rx.xtalTrim;
    }
    dw3000_set_xtal_trim(inst, xtal_trim);

    chan = config->channel;
    scp = ((config->rx.preambleCodeIndex > 24) ||
                   (config->tx.preambleCodeIndex > 24)) ? 1 : 0;
    /* For the dw3000, the prf is set implicitly from the preamble-code used.
     * Here we infer the RX-prf from the preamblecode used.  */
    config->prf = (config->rx.preambleCodeIndex<9) ? DWT_PRF_16M :
        (config->rx.preambleCodeIndex<0x19) ? DWT_PRF_64M : DWT_PRF_SCP;
    phrMode = (config->rx.phrMode == DWT_PHRMODE_EXT) ? SYS_CFG_PHR_MODE_BIT_MASK : 0;
    rxauto = (config->rxauto_enable) ? SYS_CFG_RXAUTR_BIT_MASK : 0;
    sts_len = GET_STS_REG_SET_VALUE((uint16_t)config->rx.stsLength);

#define DW3000_API_ERROR_CHECK
#ifdef DW3000_API_ERROR_CHECK
    assert((config->dataRate == DWT_BR_6M8) || (config->dataRate == DWT_BR_850K));
    assert(config->rx.pacLength <= DWT_PAC4);
    assert((chan == 5) || (chan == 9));

    assert((config->tx.preambleLength == DWT_PLEN_32) ||
           (config->tx.preambleLength == DWT_PLEN_64) || (config->tx.preambleLength == DWT_PLEN_128) ||
           (config->tx.preambleLength == DWT_PLEN_256)|| (config->tx.preambleLength == DWT_PLEN_512) ||
           (config->tx.preambleLength == DWT_PLEN_1024) ||
           (config->tx.preambleLength == DWT_PLEN_1536) ||
           (config->tx.preambleLength == DWT_PLEN_2048) ||
           (config->tx.preambleLength == DWT_PLEN_4096));

    assert((config->rx.phrMode == DWT_PHRMODE_STD) || (config->rx.phrMode == DWT_PHRMODE_EXT));
    assert((config->rx.phrRate == DWT_PHRRATE_STD) || (config->rx.phrRate == DWT_PHRRATE_DTA));
#endif

    switch(config->tx.preambleLength)
    {
        case DWT_PLEN_32:
            preamble_len = 32;
            break;
        case DWT_PLEN_64:
            preamble_len = 64;
            break;
        case DWT_PLEN_128:
            preamble_len = 128;
            break;
        default:
            preamble_len = 256;
            break;
    }
    /* clear the sleep mode ALT_GEAR bit */
    inst->sleep_mode &= (~(DWT_ALT_GEAR | DWT_SEL_GEAR3));

#define STSQUAL_THRESH_64 (90)
#define STSQUAL_THRESH_16 (70)
    /* cipher quality thereshold values for 16/64 MHz PRF (24,32 are currently not supported)
     * when using 16 MHz PRF the cipherCpQual should be > 75 % of CP length (no longer used?)
     * when using 64 MHz PRF the cipherCpQual should be > 90 % of CP length */
    inst->sts_threshold = (int16_t)(
        (((uint32_t)sts_len) * 8) * STSQUAL_THRESH_64) / 100;

    /* Clear the PHR Mode, PHR Rate, STS Protocol, SDC, PDOA Mode,
     * then set phrMode, phrRate, and SCP if needed */
    dw3000_modify_reg(inst, SYS_CFG_ID, 0, (uint32_t)
                      ~(SYS_CFG_PHR_MODE_BIT_MASK | SYS_CFG_PHR_6M8_BIT_MASK |
                        SYS_CFG_CP_PROTOCOL_BIT_MASK | SYS_CFG_PDOA_MODE_BIT_MASK |
                        SYS_CFG_CP_SDC_BIT_MASK | SYS_CFG_RXAUTR_BIT_MASK),
                      ((uint32_t)config->rx.pdoaMode) << SYS_CFG_PDOA_MODE_BIT_OFFSET |
                      ((uint32_t)config->rx.stsMode & DWT_STS_CONFIG_MASK) << SYS_CFG_CP_PROTOCOL_BIT_OFFSET |
                      (SYS_CFG_PHR_6M8_BIT_MASK & ((uint32_t)config->rx.phrRate << SYS_CFG_PHR_6M8_BIT_OFFSET)) |
                      rxauto | phrMode,
                      sizeof(uint32_t));

    if (scp) {
        /* configure gearing tables for SCP mode */
        inst->sleep_mode |= DWT_ALT_GEAR | DWT_SEL_GEAR1;
        dw3000_modify_reg(inst, NVM_CFG_ID, 0, ~(NVM_CFG_GEAR_ID_BIT_MASK),
                          DWT_OPSET_SCP | NVM_CFG_GEAR_KICK_BIT_MASK, sizeof(uint32_t));

        dw3000_modify_reg(inst, IP_CONFIG_LO_ID, 0,
                          ~(IP_CONFIG_LO_IPNOISELENGTH_BIT_MASK |
                            IP_CONFIG_LO_NOISETHRESHOLDMULTIPLIER_BIT_MASK |
                            IP_CONFIG_LO_PEAKMULTIPLIER_BIT_MASK),
                          (0x2 << IP_CONFIG_LO_IPNOISELENGTH_BIT_OFFSET) | 0x6,
                          sizeof(uint32_t));
        dw3000_modify_reg(inst, IP_CONFIG_HI_ID, 0, (uint32_t)
                          ~(IP_CONFIG_HI_IGNOREWINDOW_BIT_MASK |
                            IP_CONFIG_HI_REPLICATHRESHOLDMULTIPLIER_BIT_MASK),
                          0, sizeof(uint32_t));

        dw3000_modify_reg(inst, CY_CONFIG_LO_ID, 0, (uint32_t)
                          ~(CY_CONFIG_LO_MANUALLOWERBOUND_BIT_MASK |
                           CY_CONFIG_LO_CYIGNOREWINDOW_BIT_MASK |
                           CY_CONFIG_LO_NOISETHRESHOLDMULTIPLIER_BIT_MASK),
                         (0xC << CY_CONFIG_LO_MANUALLOWERBOUND_BIT_OFFSET) |
                         (0xB << CY_CONFIG_LO_CYIGNOREWINDOW_BIT_OFFSET) |
                         (0xA << CY_CONFIG_LO_NOISETHRESHOLDMULTIPLIER_BIT_OFFSET),
                         sizeof(uint32_t));
        dw3000_modify_reg(inst, CY_CONFIG_HI_ID, 0,
                          (uint8_t)~CY_CONFIG_HI_SFDCOUNTTHRESHOLD_BIT_MASK,
                          0xD, sizeof(uint8_t));
    } else {
        uint16_t sts_mnth;

        if (config->rx.stsMode != DWT_STS_MODE_OFF) {
            /* configure CIA STS lower bound */
            if ((config->rx.pdoaMode == DWT_PDOA_M1) || (config->rx.pdoaMode == DWT_PDOA_M0)) {
                 /* In PDOA mode 1, number of accumulated symbols is
                  * the whole length of the sts */
                sts_mnth = get_sts_mnth(sts_length_factors[(uint8_t)(config->rx.stsLength)],
                                        CIA_MANUALLOWERBOUND_TH_64, 3);
            } else {
                 /* In PDOA modes 2, 3 number of accumulated symbols
                  * is half of the length of sts symbols */
                sts_mnth = get_sts_mnth(sts_length_factors[(uint8_t)(config->rx.stsLength)],
                                        CIA_MANUALLOWERBOUND_TH_64, 4);
            }

            preamble_len += (sts_len) * 8;

            dw3000_modify_reg(inst, CY_CONFIG_LO_ID, 2,
                              ~((uint32_t)CY_CONFIG_LO_MANUALLOWERBOUND_BIT_MASK >> 16),
                              sts_mnth & 0x7F,
                              sizeof(uint16_t));
        }

        //configure gearing tables for non-SCP mode
        if (preamble_len >= 256) {
            inst->sleep_mode |= DWT_ALT_GEAR | DWT_SEL_GEAR0;
            dw3000_modify_reg(inst, NVM_CFG_ID, 0, ~((uint32_t)NVM_CFG_GEAR_ID_BIT_MASK),
                              DWT_OPSET_LONG | NVM_CFG_GEAR_KICK_BIT_MASK, sizeof(uint32_t));
        } else {
            dw3000_modify_reg(inst, NVM_CFG_ID, 0, ~((uint32_t)NVM_CFG_GEAR_ID_BIT_MASK),
                              DWT_OPSET_SHORT | NVM_CFG_GEAR_KICK_BIT_MASK, sizeof(uint32_t));
        }
    }

    dw3000_modify_reg(inst, DTUNE0_ID, 0, (uint8_t) ~DTUNE0_PRE_PAC_SYM_BIT_MASK, config->rx.pacLength, sizeof(uint8_t));
    dw3000_write_reg(inst, CP_CFG0_ID, 0, config->rx.stsLength, sizeof(uint8_t));

    if((config->rx.stsMode & DWT_STS_MODE_ND) == DWT_STS_MODE_ND) {
        //configure lower preamble detection threshold for no data STS mode
        dw3000_write_reg(inst, DTUNE3_ID, 0, PD_THRESH_NO_DATA, sizeof(uint32_t));
    }

    reg32 = dw3000_read_reg(inst, CHAN_CTRL_ID, 0, sizeof(uint32_t));
    reg32 &= (~(CHAN_CTRL_RX_PCODE_BIT_MASK | CHAN_CTRL_TX_PCODE_BIT_MASK |
                CHAN_CTRL_SFD_TYPE_BIT_MASK | CHAN_CTRL_RF_CHAN_BIT_MASK));

    if (chan == 9) {
        reg32 |= CHAN_CTRL_RF_CHAN_BIT_MASK;
    }
    reg32 |= (CHAN_CTRL_RX_PCODE_BIT_MASK & ((uint32_t)config->rx.preambleCodeIndex << CHAN_CTRL_RX_PCODE_BIT_OFFSET));
    reg32 |= (CHAN_CTRL_TX_PCODE_BIT_MASK & ((uint32_t)config->tx.preambleCodeIndex << CHAN_CTRL_TX_PCODE_BIT_OFFSET));
    reg32 |= (CHAN_CTRL_SFD_TYPE_BIT_MASK & ((uint32_t)config->rx.sfdType << CHAN_CTRL_SFD_TYPE_BIT_OFFSET));

    dw3000_write_reg(inst, CHAN_CTRL_ID, 0, reg32, sizeof(uint32_t));

    // Set up TX Preamble Size and Data Rate
    inst->tx_fctrl = ((uint32_t)config->dataRate << TX_FCTRL_TXBR_BIT_OFFSET) |
        ((uint32_t)(config->tx.preambleLength>>2) << TX_FCTRL_TXPSR_PE_BIT_OFFSET);
    dw3000_write_reg(inst, TX_FCTRL_ID, 0, inst->tx_fctrl, sizeof(uint32_t));

    if (config->tx.preambleLength == DWT_PLEN_72) {
        /* value 9 sets preamble length to 72 symbols - this is needed
         * to set 72 length. */
        dw3000_write_reg(inst, TX_FCTRL_HI_ID, 1, 9, sizeof(uint8_t));
    } else {
        /* clear the setting in the FINE_PLEN register. */
        dw3000_write_reg(inst, TX_FCTRL_HI_ID, 1, 0, sizeof(uint8_t));
    }

    // Don't allow 0 - SFD timeout will always be enabled
    if (config->rx.sfdTimeout == 0) {
        config->rx.sfdTimeout = DWT_SFDTOC_DEF;
    }
    dw3000_write_reg(inst, DTUNE0_ID, DTUNE0_RX_SFD_TOC_BIT_OFFSET/8,
                     config->rx.sfdTimeout, sizeof(uint16_t));

    /* disable DGC */
    dw3000_modify_reg(inst, DGC_CFG_ID, 0, 0xfe, 0x0, sizeof(uint8_t));

    if (chan == 9) {
        /* TX Analog setup for ch9 */
        dw3000_write_reg(inst, TX_CTRL_HI_ID, 0, RF_TXCTRL_CH9, sizeof(uint32_t));
        dw3000_write_reg(inst, PLL_CFG_ID, 0, RF_PLL_CFG_CH9, sizeof(uint16_t));
        /* RX Analog setup for ch9 */
        dw3000_write_reg(inst, RX_CTRL_HI_ID, 0, RF_RXCTRL_CH9, sizeof(uint32_t));
    } else {
        /* TX Analog setup for ch5 */
        dw3000_write_reg(inst, TX_CTRL_HI_ID, 0, RF_TXCTRL_CH5, sizeof(uint32_t));
        dw3000_write_reg(inst, PLL_CFG_ID, 0, RF_PLL_CFG_CH5, sizeof(uint16_t));
        /* RX_CTRL_HI_ID isn't used for channel 5 */
    }

    dw3000_phy_setdwstate(inst, DWT_DW_IDLE);
    dw3000_phy_config_mrx_lut(inst, chan);

    timeout = 10;
retry_cal:
    dpl_cputime_delay_usecs(1000);
    timeout--;
    /* (Re-)Run PLL Calibration, TODO: Doesn't always work for ch9! */
    dw3000_phy_force_clocks(inst, FORCE_CLK_FOSC);
    dw3000_modify_reg(inst, PLL_CAL_ID, 0, ~(PLL_CAL_PLL_USE_OLD_BIT_MASK),
                      PLL_CAL_PLL_CAL_EN_BIT_MASK, sizeof(uint16_t));
    dpl_cputime_delay_usecs(5);
    reg32 = dw3000_read_reg(inst, PLL_STATUS_ID, 0, sizeof(uint32_t));

    if (!(reg32&PLL_STATUS_LD_CODE_BIT_MASK) && timeout) {
        goto retry_cal;
    }
    reg32 = dw3000_read_reg(inst, RF_STATUS_ID, 0, sizeof(uint32_t));
    if (!(reg32&RF_STATUS_PLL1_MID_FLAG_BIT_MASK) && timeout) {
        goto retry_cal;
    }
    if ((reg32&RF_STATUS_PLL1_HI_FLAG_BIT_MASK) && timeout) {
        goto retry_cal;
    }
    if (!(reg32&RF_STATUS_PLL1_LO_FLAG_BIT_MASK) && timeout) {
        goto retry_cal;
    }

    dw3000_phy_force_clocks(inst, FORCE_CLK_AUTO);

    /* Run PGF Calibration */
    rc = dwt_pgf_cal(inst, 1);
    if (rc != DWT_SUCCESS && timeout) {
        dpl_cputime_delay_usecs(1000);
        goto retry_cal;
    } else {
        assert(rc == DWT_SUCCESS);
    }

    dw3000_mac_framefilter(inst, config->rx.frameFilter);
    dw3000_set_dblrxbuff(inst, config->dblbuffon_enabled);
    /* Allocate Indirect pointer B to dblbuf handling */
    dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint8_t));
    dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint16_t));

    return inst->uwb_dev.status;
}


/**
 * API to initialize the mac layer.
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param config   Pointer to struct uwb_dev_config.
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status dw3000_mac_init(struct _dw3000_dev_instance_t * inst, struct uwb_dev_config * config)
{
    /* Configure DW3000 */
    dw3000_mac_config(inst, config);

    dw3000_tasks_init(inst);

#if MYNEWT_VAL(DW3000_MAC_STATS)
    {
        int rc = stats_init(
            STATS_HDR(inst->stat),
            STATS_SIZE_INIT_PARMS(inst->stat, STATS_SIZE_32),
            STATS_NAME_INIT_PARMS(dw3000_mac_stat_section));
        assert(rc == 0);

#if  MYNEWT_VAL(DW3000_DEVICE_0) && !MYNEWT_VAL(DW3000_DEVICE_1)
        rc = stats_register("3kmac", STATS_HDR(inst->stat));
#elif  MYNEWT_VAL(DW3000_DEVICE_0) && MYNEWT_VAL(DW3000_DEVICE_1)
        if (inst == hal_dw3000_inst(0))
            rc |= stats_register("3kmac0", STATS_HDR(inst->stat));
        else
        rc |= stats_register("3kmac1", STATS_HDR(inst->stat));
#endif
        assert(rc == 0);
    }
#endif

    return inst->uwb_dev.status;
}


/**
 * @fn dw3000_set_xtal_trim()
 *
 * @brief This is used to adjust the crystal frequency
 *
 * input parameters:
 * @param   value - crystal trim value (in range 0x0 to 0x7F) 128 steps  (~1.65ppm per step)
 *
 * output parameters
 *
 * no return value
 */
void dw3000_set_xtal_trim(struct _dw3000_dev_instance_t * inst, uint8_t value)
{
    uint8_t reg_val = ((value & XTAL_XTAL_TRIM_BIT_MASK) >> XTAL_XTAL_TRIM_BIT_OFFSET);
    dw3000_write_reg(inst, XTAL_ID, 0, reg_val, sizeof(uint8_t));
}

/**
 * @fn dw3000_mac_cp_set_key()
 *
 * @brief Sets the ciphered AES 128 bit key
 *
 * input parameters
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param key - this is a 16 byte array which holds the AES key value to program *
 *
 * output parameters
 *
 * no return value
 */
void
dw3000_mac_cp_set_key(struct _dw3000_dev_instance_t * inst, struct uwb_sts_cp_key *key)
{
    dw3000_write(inst, CP_KEY0_ID, 0, key->array, sizeof(struct uwb_sts_cp_key));
}

/**
 * @fn dw3000_mac_cp_set_iv()
 *
 * @brief This function configures the ciphered preamble 128 bit initial value
 *
 * input parameters
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param iv - this is a 16 byte array which holds the IV value to program
 *
 * no return value
 */
void
dw3000_mac_cp_set_iv(struct _dw3000_dev_instance_t * inst, struct uwb_sts_cp_iv *iv)
{
    dw3000_write(inst, CP_IV0_ID, 0, iv->array, sizeof(struct uwb_sts_cp_iv));
}

/**
 * @fn dw3000_mac_cp_load_iv()
 *
 * @brief This function re-loads the ciphered preamble initial value
 *
 * input parameters
 * @param inst     Pointer to _dw3000_dev_instance_t.
 *
 * no return value
 */
void
dw3000_mac_cp_load_iv(struct _dw3000_dev_instance_t * inst)
{
    dw3000_modify_reg(inst, CP_CFG0_ID, 0, 0xFF,
                      CP_CTRL_CP_LOAD_IV_BIT_MASK, sizeof(uint8_t));
}

static int
dwt_pgf_cal(struct _dw3000_dev_instance_t * inst, int ldoen)
{
    int rc;
    uint16_t val;

    //Turn on RX LDOs
    //PGF needs LDOs turned on - ensure PGF LDOs are enabled
    if (ldoen == 1) {
        val = dw3000_read_reg(inst, LDO_CTRL_ID, 0, sizeof(uint16_t));
        dw3000_modify_reg(inst, LDO_CTRL_ID, 0, 0xffffffff,
                          (LDO_CTRL_LDO_VDDIF2_EN_BIT_MASK |
                           LDO_CTRL_LDO_VDDMS3_EN_BIT_MASK |
                           LDO_CTRL_LDO_VDDMS1_EN_BIT_MASK),
                          sizeof(uint16_t));
    }

    //Run PGF Cal
    rc = dwt_run_pgfcal(inst);

    // Restore register to original value
    if (ldoen == 1) {
        dw3000_write_reg(inst, LDO_CTRL_ID, 0, val, sizeof(uint16_t));
    }
    return rc;
}

static int
dwt_run_pgfcal(struct _dw3000_dev_instance_t * inst)
{
    int rc=DWT_SUCCESS;
    uint16_t timeout = 100;
    uint32_t data, val = 0;
    /* Place in cal mode */
    data = (((uint32_t)0x02) << PGF_CAL_CFG_COMP_DLY_BIT_OFFSET) | (PGF_CAL_CFG_PGF_MODE_BIT_MASK & 0x1);
    dw3000_write_reg(inst, PGF_CAL_CFG_ID, 0x0, data, sizeof(uint32_t));
    /* Short PGF inputs */
    dw3000_write_reg(inst, RX_TEST_ID, 0x0, RX_TEST_PGF_AC_SHORT_EN_BIT_MASK, sizeof(uint16_t));

    /* Trigger PGF Cal */
    dw3000_modify_reg(inst, PGF_CAL_CFG_ID, 0x0, 0xff, PGF_CAL_CFG_CAL_EN_BIT_MASK, sizeof(uint8_t));

    /* Return to normal mode */
    dw3000_write_reg(inst, PGF_CAL_CFG_ID, 0x0, 0, sizeof(uint32_t));
     /* unShort PGF inputs */
    dw3000_write_reg(inst, RX_TEST_ID, 0x0, 0, sizeof(uint16_t));

    /* Read cal status */
    while ((val = dw3000_read_reg(inst, PGF_CAL_STS_ID, 0x0, sizeof(uint8_t))) != 1 &&
           --timeout>0);
    if (!timeout) {
        rc = DWT_ERROR;
        printf("%s:%d:I calibration timeout\n", __func__, __LINE__);
    }

    /* clear the status */
    dw3000_write_reg(inst, PGF_CAL_STS_ID, 0x0, 1, sizeof(uint8_t));
    val = dw3000_read_reg(inst, PGF_I_CTRL1_ID, 0x0, sizeof(uint32_t));
    if (val == 0x1fffffff) {
        /* PGF I Cal Fail */
        rc = DWT_ERROR;
        printf("%s:%d:I calibration fail\n", __func__, __LINE__);
    }
    val = dw3000_read_reg(inst, PGF_Q_CTRL1_ID, 0x0, sizeof(uint32_t));
    if (val == 0x1fffffff) {
        /* PGF Q Cal Fail */
        rc = DWT_ERROR;
        printf("%s:%d:Q calibration fail\n", __func__, __LINE__);
    }

    return rc;
}

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief this function enables CIA diagnostic data. When turned on the following registers will be logged:
 * IP_TOA_LO, IP_TOA_HI, CY0_TOA_LO, CY0_TOA_HI, CY1_TOA_LO, CY1_TOA_HI, CIA_TDOA_0, CIA_TDOA_1_PDOA, CIA_DIAG_0, CIA_DIAG_1
 *
 * input parameters
 * @param inst              Pointer to _dw3000_dev_instance_t
 * @param enable_mask :     DW_CIA_DIAG_LOG_MAX (0x8)   //CIA to copy to swinging set a maximum set of diagnostic registers in Double Buffer mode
 *                          DW_CIA_DIAG_LOG_MID (0x4)   //CIA to copy to swinging set a medium set of diagnostic registers in Double Buffer mode
 *                          DW_CIA_DIAG_LOG_MIN (0x2)   //CIA to copy to swinging set a minimal set of diagnostic registers in Double Buffer mode
 *                          DW_CIA_DIAG_LOG_ALL (0x1)   //CIA to log all diagnostic registers
 *                          DW_CIA_DIAG_LOG_OFF (0x0)   //CIA to log reduced set of diagnostic registers
 *
 * output parameters
 *
 * no return value
 */
void
dw3000_configciadiag(struct _dw3000_dev_instance_t * inst, uint8_t enable_mask)
{
    if(enable_mask & DW_CIA_DIAG_LOG_ALL) {
        dw3000_modify_reg(inst, RX_ANTENNA_DELAY_ID, 2, ~(CIA_DIAGNOSTIC_OFF), 0, sizeof(uint8_t));
    } else {
        dw3000_modify_reg(inst, RX_ANTENNA_DELAY_ID, 2, 0xff, CIA_DIAGNOSTIC_OFF, sizeof(uint8_t));
    }

    dw3000_write_reg(inst, RDB_DIAG_MODE_ID, 0, enable_mask>>1, sizeof(uint8_t));
}

static uint8_t
_configciadiag(struct _dw3000_dev_instance_t * inst)
{
    uint16_t en = inst->rxdiag.rxd.enabled;

    if (en&(UWB_RXDIAG_IPATOV|UWB_RXDIAG_STS|UWB_RXDIAG_STS2)) {
        return DW_CIA_DIAG_LOG_ALL|DW_CIA_DIAG_LOG_MAX;
    } else if (en&(UWB_RXDIAG_IPATOV_RXTIME|UWB_RXDIAG_STS_RXTIME|UWB_RXDIAG_STS2_RXTIME)) {
        /* MID level */
        return DW_CIA_DIAG_LOG_ALL|DW_CIA_DIAG_LOG_MID;
    } else if (en == 0x0) {
        /* OFF */
        return DW_CIA_DIAG_LOG_OFF|DW_CIA_DIAG_LOG_MIN;
    }
    /* MIN level as default */
    return DW_CIA_DIAG_LOG_ALL|DW_CIA_DIAG_LOG_MIN;
}


/**
 * API to read the supplied RX data from the DW3000's
 * TX buffer.The input parameters are the data length in bytes and a pointer
 * to those data bytes.
 *
 * @param inst              Pointer to _dw3000_dev_instance_t.
 * @param rxFrameLength     This is the total frame length, including the two byte CRC.
 * Note: This is the length of RX message (including the 2 byte CRC) - max is 1023 standard PHR mode allows up to 127 bytes
 * if > 127 is programmed, DWT_PHRMODE_EXT needs to be set in the phrMode configuration.
 *
 * @param rxFrameBytes      Pointer to the user buffer containing the data to send.
 * @param rxBufferOffset    This specifies an offset in the DW3000s TX Buffer where writing of data starts.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status dw3000_read_rx(struct _dw3000_dev_instance_t * inst,  uint8_t * rxFrameBytes, uint16_t rxBufferOffset, uint16_t rxFrameLength)
{
    dpl_error_t err;
    uint32_t rx_buff_addr = RX_BUFFER_A_ID;
#ifdef DW3000_API_ERROR_CHECK
    assert((inst->uwb_dev.config.rx.phrMode && (rxFrameLength <= 1023)) || (rxFrameLength <= 127));
    assert((rxBufferOffset + rxFrameLength) <= 1024);
#endif
    MAC_STATS_INCN(rx_bytes, rxFrameLength);

    err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    if (inst->uwb_dev.status.dblbuff_current == DBL_BUFF_ACCESS_BUFFER_B) {
        rx_buff_addr = RX_BUFFER_B_ID;
    }

    if(rxBufferOffset <= REG_DIRECT_OFFSET_MAX_LEN) {
        dw3000_read(inst, rx_buff_addr, rxBufferOffset, rxFrameBytes, rxFrameLength);
    } else {
        /* Program the indirect offset registers B for specified offset to RX buffer */
        dw3000_write_reg(inst, INDIRECT_ADDR_A_ID, 0, (rx_buff_addr >> 16), sizeof(uint32_t));
        dw3000_write_reg(inst, ADDR_OFFSET_A_ID, 0, rxBufferOffset, sizeof(uint32_t));

        /* Indirectly read data from the IC to the buffer */
        dw3000_read(inst, INDIRECT_POINTER_A_ID, 0, rxFrameBytes, rxFrameLength);
    }
    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

/**
 * API to write the supplied TX data into the DW3000's
 * TX buffer.The input parameters are the data length in bytes and a pointer
 * to those data bytes.
 *
 * @param inst              Pointer to _dw3000_dev_instance_t.
 * @param txFrameLength     This is the length of TX message, excluding the two byte CRC when auto-FCS
 *                          transmission is enabled.
 *                          In standard PHR mode, maximum is 127 (125 with auto-FCS Transmission).
 *                          With DWT_PHRMODE_EXT set in the phrMode configuration, maximum is 1023 (1021 with
 *                          auto-FCS Transmission).
 *
 * @param txFrameBytes      Pointer to the user buffer containing the data to send.
 * @param txBufferOffset    This specifies an offset in the DW3000s TX Buffer where writing of data starts.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status dw3000_write_tx(struct _dw3000_dev_instance_t * inst,  uint8_t * txFrameBytes, uint16_t txBufferOffset, uint16_t txFrameLength)
{
    uint8_t i;
    dpl_error_t err;
#ifdef DW3000_API_ERROR_CHECK
    assert((inst->uwb_dev.config.rx.phrMode && (txFrameLength <= 1023)) || (txFrameLength <= 127));
    assert((txBufferOffset + txFrameLength) <= 1024);
#endif
    MAC_STATS_INCN(tx_bytes, txFrameLength);

    err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    if ((txBufferOffset + txFrameLength) <= 1024){

        if(txBufferOffset <= REG_DIRECT_OFFSET_MAX_LEN) {
            dw3000_write(inst, TX_BUFFER_ID, txBufferOffset,  txFrameBytes, txFrameLength);
        } else {
            /* Program the indirect offset registers A for specified offset to RX buffer */
            dw3000_write_reg(inst, INDIRECT_ADDR_A_ID, 0, (TX_BUFFER_ID >> 16), sizeof(uint32_t));
            dw3000_write_reg(inst, ADDR_OFFSET_A_ID, 0, txBufferOffset, sizeof(uint32_t));

            /* Indirectly write the data to the IC TX buffer */
            dw3000_write(inst, INDIRECT_POINTER_A_ID, 0, txFrameBytes, txFrameLength);
        }

        /* This is only valid if the offset is 0, and not always then either  */
        if (txBufferOffset == 0) {
            for (i = 0; i< sizeof(inst->uwb_dev.fctrl); i++)
                inst->uwb_dev.fctrl_array[i] =  txFrameBytes[i];
        }
        inst->uwb_dev.status.tx_frame_error = 0;
    }
    else
        inst->uwb_dev.status.tx_frame_error = 1;

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

/**
 * API to configure the TX frame control register before the transmission of a frame.
 *
 * @param inst              pointer to _dw3000_dev_instance_t.
 * @param txFrameLength     This is the length of TX message, excluding the two byte CRC when auto-FCS
 *                          transmission is enabled.
 *                          In standard PHR mode, maximum is 127 (125 with auto-FCS Transmission).
 *                          With DWT_PHRMODE_EXT set in the phrMode configuration, maximum is 1023 (1021 with
 *                          auto-FCS Transmission).
 *
 * @param txBufferOffset    The offset in the tx buffer to start writing the data.
 * @param ext               Optional pointer to struct uwb_fctrl_ext with additional parameters
 * @return void
 */
inline void dw3000_write_tx_fctrl(struct _dw3000_dev_instance_t * inst, uint16_t txFrameLength,
                                  uint16_t txBufferOffset, struct uwb_fctrl_ext *ext)
{
    dpl_error_t err;
    uint8_t tx_fctrl_hi_reg = 0;
    uint32_t tx_fctrl_reg;
    uint16_t offset_adjust = 0;
    struct uwb_dev_config * config = &inst->uwb_dev.config;
#ifdef DW3000_API_ERROR_CHECK
    assert((config->rx.phrMode && ((txFrameLength + 2) <= 1023)) || ((txFrameLength +2) <= 127));
#endif
    err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    /* C0 and D0 has a tx_buffer offset issue (MOR-2174). The workaround involves
     * adding 128 to the txBufferOffset value written. This will be subtracted away internally
     * and the device will send from the offset given. */
    if ((inst->uwb_dev.device_id&DEV_ID_REV_BIT_MASK) < 0x4) {
        if (txBufferOffset > 127) {
            offset_adjust = 128;
        }
    }

    /* Start from current base tx_fctrl or override with ext params? */
    if (ext) {
        tx_fctrl_reg = ((uint32_t)(ext->preambleLength>>2) << TX_FCTRL_TXPSR_PE_BIT_OFFSET) |
            (((uint32_t)ext->dataRate) << TX_FCTRL_TXBR_BIT_OFFSET) |
            (((uint32_t)ext->ranging_en_bit) << TX_FCTRL_TR_BIT_OFFSET);
        if (ext->preambleLength == DWT_PLEN_72) {
            /* value 9 sets preamble length to 72 symbols - this is needed
             * to set 72 length. */
            tx_fctrl_hi_reg = 9;
        }
    } else {
        tx_fctrl_reg = inst->tx_fctrl;
        if (config->tx.preambleLength == DWT_PLEN_72) {
            tx_fctrl_hi_reg = 9;
        }
    }
    dw3000_write_reg(inst, TX_FCTRL_HI_ID, 1, tx_fctrl_hi_reg, sizeof(uint8_t));

    /* Add frame length (+2 for CRC) and start-offset */
    tx_fctrl_reg |= ((txFrameLength>0) ? txFrameLength + 2 : 0) | ((uint32_t)(txBufferOffset + offset_adjust) << TX_FCTRL_TXB_OFFSET_BIT_OFFSET);
    dw3000_write_reg(inst, TX_FCTRL_ID, 0, tx_fctrl_reg, sizeof(uint32_t));

    /* C0/D0 tx_buffer offset issue workaround continued. We need to read from 0x80000 to
     * latch the offset internally */
    if ((inst->uwb_dev.device_id&DEV_ID_REV_BIT_MASK) < 0x4) {
        dw3000_read_reg(inst, SAR_CTRL_ID, 0, sizeof(uint8_t));
    }

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return;
}

#define DW3000_USE_FAST_CMDS 1
/**
 * API to start transmission.
 *
 * @param inst  pointer to _dw3000_dev_instance_t.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_start_tx(struct _dw3000_dev_instance_t * inst)
{
    uint16_t sys_status_reg;
#if !DW3000_USE_FAST_CMDS
    uint32_t sys_ctrl_reg;
#endif
    struct uwb_dev_config config;
    dw3000_dev_control_t control;
    dpl_error_t err = dpl_sem_pend(&inst->tx_sem,  DPL_TIMEOUT_NEVER); // Released by a SYS_STATUS_TXFRS event
    if (err != DPL_OK) {
        inst->uwb_dev.status.sem_error = 1;
        goto sem_error;
    }

    config = inst->uwb_dev.config;
    control = inst->control;

    /* force return to idle state */
    if (config.trxoff_enable){
        /* XXX C0 Bug which prevents us from issuing TRXOFF if the device is
        * already in idle */
        uint32_t sys_state = dw3000_read_reg(inst, SYS_STATE_LO_ID, 0, sizeof(uint32_t));
        uint8_t fcmd_running = dw3000_read_reg(inst, FCMD_STATUS_ID, 0, sizeof(uint8_t));
        if ((sys_state & SYS_STATE_TX_RX_IDLE_MASK) != 0 || fcmd_running) {
            dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
        }
    }

    inst->uwb_dev.status.start_tx_error = 0;
    if (control.delay_start_enabled || control.delay_wrt_ref_start_enabled ||
        control.delay_wrt_rs_start_enabled || control.delay_wrt_ts_start_enabled)
    {
#if DW3000_USE_FAST_CMDS
        if (control.delay_start_enabled) {
            if (control.wait4resp_enabled){
                /* Delayed tx, rx turned on instantly after */
                dw3000_write_fast_CMD(inst, CMD_DTX_W4R);
            } else {
                /* Delayed tx, rx not turned on after */
                dw3000_write_fast_CMD(inst, CMD_DTX);
            }
        } else if (control.delay_wrt_rs_start_enabled) {
            if (control.wait4resp_enabled){
                /* Delayed tx with respect to rx timestamp,
                 * rx turned on instantly after */
                dw3000_write_fast_CMD(inst, CMD_DTX_RS_W4R);
            } else {
                /* Delayed tx with respect to rx timestamp,
                 * rx not turned on after */
                dw3000_write_fast_CMD(inst, CMD_DTX_RS);
            }
        } else if (control.delay_wrt_ts_start_enabled) {
            if (control.wait4resp_enabled){
                /* Delayed tx with respect to tx timestamp,
                 * rx turned on instantly after */
                dw3000_write_fast_CMD(inst, CMD_DTX_TS_W4R);
            } else {
                /* Delayed tx with respect to tx timestamp,
                 * rx not turned on after */
                dw3000_write_fast_CMD(inst, CMD_DTX_TS);
            }
        } else if (control.delay_wrt_ref_start_enabled) {
            if (control.wait4resp_enabled){
                /* Delayed tx with respect to tx timestamp,
                 * rx turned on instantly after */
                dw3000_write_fast_CMD(inst, CMD_DTX_REF_W4R);
            } else {
                /* Delayed tx with respect to tx timestamp,
                 * rx not turned on after */
                dw3000_write_fast_CMD(inst, CMD_DTX_REF);
            }
        }
#else
        sys_ctrl_reg = SYS_CTRL_TXSTRT_BIT_MASK;
        if (control.wait4resp_enabled) {
            sys_ctrl_reg |= SYS_CTRL_WAIT4RESP_BIT_MASK;
        }
        if (control.delay_start_enabled) {
            sys_ctrl_reg |= SYS_CTRL_TXDLYS_BIT_MASK;
        }
        dw3000_write_reg(inst, SYS_CTRL_ID, 0, sys_ctrl_reg, sizeof(uint16_t));
#endif
        /* Check for Half Period warning - usually indicates we were too late */
        sys_status_reg = dw3000_read_reg(inst, SYS_STATUS_ID, 3, sizeof(uint16_t)); // Read at offset 3 to get the upper 2 bytes out of 5
        inst->uwb_dev.status.start_tx_error = ((sys_status_reg & (SYS_STATUS_HPDWARN_BIT_MASK>>24)) != 0);
        if ((inst->uwb_dev.device_id&DEV_ID_REV_BIT_MASK) < 0x3) {
            /* C0 bug-workaround for when the HPDWARN fails to set.
             * TSE enters TX (0x0D) but TX_STATE is stuck in IDLE (0x00)*/
            inst->uwb_dev.status.start_tx_error|= (dw3000_read_reg(inst, SYS_STATE_LO_ID, 0, 4) == 0x000D0000);
        }
        if (inst->uwb_dev.status.start_tx_error) {
            /*
            * Half Period Delay Warning (HPDWARN) OR Power Up error (TXPUTE). This event status bit relates to the
            * use of delayed transmit and delayed receive functionality. It indicates the delay is more than half
            * a period of the system clock. There is enough time to send but not to power up individual blocks.
            * Typically when the HPDWARN event is detected the host controller will abort the delayed TX/RX by issuing
            * a TRXOFF transceiver off command and then take whatever remedial action is deemed appropriate for the application.
            * Remedial action is cancel send and report error
            */
            dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
            err = dpl_sem_release(&inst->tx_sem);
            assert(err == DPL_OK);
        }

    } else if (control.cca_tx) {
        if (control.wait4resp_enabled){
            /* Check if channel clear prior to TX, enable RX when TX done */
            dw3000_write_fast_CMD(inst, CMD_CCA_TX_W4R);
        } else {
            /* Check if channel clear prior to TX */
            dw3000_write_fast_CMD(inst, CMD_CCA_TX);
        }
    } else {
#if DW3000_USE_FAST_CMDS
        if (control.wait4resp_enabled){
            /* Direct tx with
             * rx turned on instantly after */
            dw3000_write_fast_CMD(inst, CMD_TX_W4R);
        } else {
            /* Direct tx only */
            dw3000_write_fast_CMD(inst, CMD_TX);
        }
#else
        sys_ctrl_reg = SYS_CTRL_TXSTRT_BIT_MASK;
        if (control.wait4resp_enabled) {
            sys_ctrl_reg |= SYS_CTRL_WAIT4RESP_BIT_MASK;
        }
        dw3000_write_reg(inst, SYS_CTRL_ID, 0, sys_ctrl_reg, sizeof(uint16_t));
#endif
    }

    /* Prepare for response, if we need rxdiagnostics */
    if (control.wait4resp_enabled) {
        dw3000_configciadiag(inst, _configciadiag(inst));
    }

    /* If dw3000 is instructed to sleep after tx, release
     * the sem as there will not be a TXDONE irq */
    if(inst->control.sleep_after_tx) {
        inst->uwb_dev.status.sleeping = 1;
        err = dpl_sem_release(&inst->tx_sem);
    }

    inst->control.wait4resp_enabled = false;
    inst->control.wait4resp_delay_enabled = false;
    inst->control.delay_start_enabled = false;
    inst->control.delay_wrt_ref_start_enabled=false;
    inst->control.delay_wrt_rs_start_enabled=false;
    inst->control.delay_wrt_ts_start_enabled=false;
    inst->control.autoack_delay_enabled = false;
    inst->control.start_rx_syncbuf_enabled = false;
    inst->control.on_error_continue_enabled = false;
    inst->control.cca_tx=false;

sem_error:
    return inst->uwb_dev.status;
}

/**
 * Wait for transmission to finish
 *
 * @param inst pointer to _dw1000_dev_instance_t.
 * @param timeout timeout in ticks or DPL_TIMEOUT_NEVER
 * @return int
 */
int
dw3000_tx_wait(struct _dw3000_dev_instance_t * inst, uint32_t timeout)
{
    int rc;
    rc = dpl_sem_pend(&inst->tx_sem,  timeout);
    if (rc == DPL_OK) {
        rc = dpl_sem_release(&inst->tx_sem);
    }
    return rc;
}

/**
 * API to specify a time in future to either turn on the receiver to be ready to receive a frame,
 * or to turn on the transmitter and send a frame. The low-order 9-bits of this register are ignored.
 * The delay is in UWB microseconds * 65535.
 *
 * @param inst       Pointer to _dw3000_dev_instance_t.
 * @param dx_time    Delayed Send or receive Time.
 * @return struct uwb_dev_status
 */
static struct uwb_dev_status
_dw3000_set_delay_start(struct _dw3000_dev_instance_t * inst, uint64_t dx_time)
{
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    dw3000_write_reg(inst, DX_TIME_ID, 0, (dx_time >> 8)&0xFFFFFFFEUL, DX_TIME_LEN);

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}


/**
 * API to specify a time in future to either turn on the receiver to be ready to receive a frame,
 * or to turn on the transmitter and send a frame. The low-order 9-bits of this register are ignored. The delay is in UWB microseconds.
 *
 * @param inst       Pointer to _dw3000_dev_instance_t.
 * @param dx_time    Delayed Send or receive Time.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_set_delay_start(struct _dw3000_dev_instance_t * inst, uint64_t dx_time)
{
    inst->control.delay_start_enabled = true;
    _dw3000_set_delay_start(inst, dx_time);
    return inst->uwb_dev.status;
}

/**
 * API to specify a time in future to either turn on the receiver relative to the reference time
 * to be ready to receive a frame, or to turn on the transmitter and send a frame.
 *
 * RMARKER will be @ time = DREF_TIME + DX_TIME
 *
 * The low-order 9-bits of this register are ignored. The delay is in UWB microseconds.
 *
 * @param inst       Pointer to _dw3000_dev_instance_t.
 * @param dx_time    Delayed Send or receive Time.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_set_delay_ref_start(struct _dw3000_dev_instance_t * inst, uint64_t dx_time)
{
    inst->control.delay_wrt_ref_start_enabled = true;
    _dw3000_set_delay_start(inst, dx_time);
    return inst->uwb_dev.status;
}

/**
 * Enable or disable the Check for Carrier Active before TX
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param enable   CCA enable / disable
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_set_cca_tx(struct _dw3000_dev_instance_t * inst, bool enable)
{
    inst->control.cca_tx = enable;
    return inst->uwb_dev.status;
}

/**
 * API to specify a time in future to either turn on the receiver relative to the rx timestamp
 * to be ready to receive a frame, or to turn on the transmitter and send a frame.
 *
 * RMARKER will be @ time = RX_TIME + DX_TIME
 *
 * The low-order 9-bits of this register are ignored. The delay is in UWB microseconds.
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param dx_time  Delayed Send or receive Time.
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_set_delay_rs_start(struct _dw3000_dev_instance_t * inst, uint64_t dx_time)
{
    inst->control.delay_wrt_rs_start_enabled = true;
    _dw3000_set_delay_start(inst, dx_time);
    return inst->uwb_dev.status;
}

/**
 * API to specify a time in future to either turn on the receiver relative to the tx timestamp
 * to be ready to receive a frame, or to turn on the transmitter and send a frame.
 *
 * RMARKER will be @ time = TX_TIME + DX_TIME
 *
 * The low-order 9-bits of this register are ignored. The delay is in UWB microseconds.
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param dx_time  Delayed Send or receive Time.
 * @return struct uwb_dev_status
 */

struct uwb_dev_status
dw3000_set_delay_ts_start(struct _dw3000_dev_instance_t * inst, uint64_t dx_time)
{
    inst->control.delay_wrt_ts_start_enabled = true;
    _dw3000_set_delay_start(inst, dx_time);
    return inst->uwb_dev.status;
}


/**
 * API to keep the transceiver in reception mode to keep on receiving the data.
 *
 * @param inst  pointer to _dw3000_dev_instance_t.
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status dw3000_start_rx(struct _dw3000_dev_instance_t * inst)
{
    uint8_t sys_status;
    dw3000_dev_control_t control;
    struct uwb_dev_config config;
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    control = inst->control;
    config = inst->uwb_dev.config;
    inst->uwb_dev.status.rx_restarted = 0;

    if (config.trxoff_enable){ // force return to idle state, if in RX state
        /* XXX C0 Bug which prevents us from issuing TRXOFF if the device is
        * already in idle */
        uint32_t sys_state = dw3000_read_reg(inst, SYS_STATE_LO_ID, 0, sizeof(uint32_t));
        uint8_t fcmd_running = dw3000_read_reg(inst, FCMD_STATUS_ID, 0, sizeof(uint8_t));
        if ((sys_state & SYS_STATE_TX_RX_IDLE_MASK) != 0 || fcmd_running) {
            dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
        }
    }

    dw3000_configciadiag(inst, _configciadiag(inst));

    if (control.delay_start_enabled || control.delay_wrt_ref_start_enabled ||
        control.delay_wrt_rs_start_enabled || control.delay_wrt_ts_start_enabled)
    {
#if DW3000_USE_FAST_CMDS
        if (control.delay_start_enabled) {
            /* Delayed rx */
            dw3000_write_fast_CMD(inst, CMD_DRX);
        } else if (control.delay_wrt_rs_start_enabled) {
            /* Delayed rx with respect to rx timestamp */
            dw3000_write_fast_CMD(inst, CMD_DRX_RS);
        } else if (control.delay_wrt_ts_start_enabled) {
            /* Delayed rx with respect to tx timestamp */
            dw3000_write_fast_CMD(inst, CMD_DRX_TS);
        } else if (control.delay_wrt_ref_start_enabled) {
            /* Delayed rx with respect to rx timestamp */
            dw3000_write_fast_CMD(inst, CMD_DRX_REF);
        }
#else
        uint32_t sys_ctrl_reg = SYS_CTRL_RXENAB_BIT_MASK;
        if (control.delay_start_enabled) {
            sys_ctrl_reg |= SYS_CTRL_RXDLYE_BIT_MASK;
        }
        dw3000_write_reg(inst, SYS_CTRL_ID, 0, sys_ctrl_reg, sizeof(uint16_t));
#endif

        /* Check for errors in turning rx on in time.
         * Read 1 byte at offset 3 to get the 4th byte out of 5 */
        sys_status = dw3000_read_reg(inst, SYS_STATUS_ID, 3, sizeof(uint8_t));
        inst->uwb_dev.status.start_rx_error = (sys_status & (SYS_STATUS_HPDWARN_BIT_MASK >> 24)) != 0;

        /* if delay has passed do immediate RX on unless DWT_IDLE_ON_DLY_ERR is true */
        if (inst->uwb_dev.status.start_rx_error) {
            dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
            if (control.on_error_continue_enabled){
                dw3000_write_fast_CMD(inst, CMD_RX);
            }
        }
    } else {
        /* Immediate rx */
        dw3000_write_fast_CMD(inst, CMD_RX);
        inst->uwb_dev.status.start_rx_error = 0;
    }

    inst->control.wait4resp_enabled = false;
    inst->control.wait4resp_delay_enabled = false;
    inst->control.delay_start_enabled = false;
    inst->control.delay_wrt_ref_start_enabled=false;
    inst->control.delay_wrt_rs_start_enabled=false;
    inst->control.delay_wrt_ts_start_enabled=false;
    inst->control.autoack_delay_enabled = false;
    inst->control.start_rx_syncbuf_enabled = false;
    inst->control.on_error_continue_enabled = false;

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

/**
 * API to gracefully turnoff reception mode.
 *
 * @param inst  pointer to _dw3000_dev_instance_t.
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status dw3000_stop_rx(struct _dw3000_dev_instance_t * inst)
{
    uint32_t sys_state, mask;
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_WAIT_FOREVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    /* XXX C0 Bug which prevents us from issuing TRXOFF if the device is
     * already in idle */
    sys_state = dw3000_read_reg(inst, SYS_STATE_LO_ID, 0, sizeof(uint32_t));
    if ((sys_state & SYS_STATE_TX_RX_IDLE_MASK) == 0) {
        goto already_idle;
    }

    mask = dw3000_read_reg(inst, SYS_ENABLE_LO_ID, 0 , sizeof(uint32_t)) ; // Read set interrupt mask
    dw3000_write_reg(inst, SYS_ENABLE_LO_ID, 0, 0, sizeof(uint32_t)) ; // Clear interrupt mask - so we don't get any unwanted events
    dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
    dw3000_write_reg(inst, SYS_STATUS_ID, 0, (SYS_STATUS_ALL_TX | SYS_STATUS_ALL_RX_ERR | SYS_STATUS_ALL_RX_TO | SYS_STATUS_ALL_RX_GOOD), sizeof(uint32_t));
    dw3000_write_reg(inst, SYS_ENABLE_LO_ID, 0, mask, sizeof(uint32_t)); // Restore mask to what it was

already_idle:
    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

/**
 * API to enable wait for response feature.
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param enable   Enables/disables the wait for response feature.
 * @return struct uwb_dev_status
 */
inline struct uwb_dev_status
dw3000_set_wait4resp(struct _dw3000_dev_instance_t * inst, bool enable)
{
    inst->uwb_dev.status.rx_restarted = 0;
    inst->control.wait4resp_enabled = enable;
    return inst->uwb_dev.status;
}
/**
 * API to enable wait for feature.
 *
 * @param inst    Pointer to _dw3000_dev_instance_t.
 * @param enable  Enables wait for feature.
 *
 */
inline struct uwb_dev_status
dw3000_set_on_error_continue(struct _dw3000_dev_instance_t * inst, bool enable)
{
    inst->control.on_error_continue_enabled = enable;
    return inst->uwb_dev.status;
}


/**
 * API to set rxauto disable
 *
 * @param inst    Pointer to _dw3000_dev_instance_t.
 * @param disable  Disable mac-layer auto rx-reenable feature. The default behavior is rxauto enable, this API overrides default behavior
 * on an individual transaction such as in dw1000_rng_request or dw1000_rng_listen
 *
 */
inline struct uwb_dev_status
dw3000_set_rxauto_disable(struct _dw3000_dev_instance_t * inst, bool disable)
{
    inst->control.rxauto_disable = disable;
    return inst->uwb_dev.status;
}

/**
 * API to set Wait Timeout period.
 *
 * @param inst      pointer to _dw3000_dev_instance_t.
 * @param timeout   Indicates how long the receiver remains on from the RX enable command.The time parameter used here is in 1.0256
 * us (512/499.2MHz) units If set to 0 the timeout is disabled.
 * @return struct uwb_dev_status
 * @brief The Receive Frame Wait Timeout period is a 16-bit field. The units for this parameter are roughly 1s,
 * (the exact unit is 512 counts of the fundamental 499.2 MHz UWB clock, or 1.026 s). When employing the frame wait timeout,
 * RXFWTO should be set to a value greater than the expected RX frame duration and include an allowance for any uncertainly
 * attaching to the expected transmission start time of the awaited frame.
 * When using .rxauto_enable feature it is important to understand the role of rx_timeout, in this situation it is the timeout
 * that actually turns-off the receiver and returns the transeiver to the idle state.
 */
struct uwb_dev_status
dw3000_adj_rx_timeout(struct _dw3000_dev_instance_t * inst, uint32_t timeout)
{
    dw3000_write_reg(inst, RX_FWTO_ID, 0, timeout&RX_FWTO_FWTO_BIT_MASK, 3*sizeof(uint8_t));
    return inst->uwb_dev.status;
}

/**
 * API to set Wait Timeout period.
 *
 * @param inst      pointer to _dw3000_dev_instance_t.
 * @param timeout   Indicates how long the receiver remains on from the RX enable command.The time parameter used here is in 1.0256
 * us (512/499.2MHz) units If set to 0 the timeout is disabled.
 * @return struct uwb_dev_status
 * @brief The Receive Frame Wait Timeout period is a 16-bit field. The units for this parameter are roughly 1s,
 * (the exact unit is 512 counts of the fundamental 499.2 MHz UWB clock, or 1.026 s). When employing the frame wait timeout,
 * RXFWTO should be set to a value greater than the expected RX frame duration and include an allowance for any uncertainly
 * attaching to the expected transmission start time of the awaited frame.
 * When using .rxauto_enable feature it is important to understand the role of rx_timeout, in this situation it is the timeout
 * that actually turns-off the receiver and returns the transeiver to the idle state.
 */
struct uwb_dev_status
dw3000_set_rx_timeout(struct _dw3000_dev_instance_t * inst, uint32_t timeout)
{
    dw3000_dev_control_t control = inst->control;
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER); // Block if request pending
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    inst->uwb_dev.status.rx_timeout_error = 0;

    control.rx_timeout_enabled = timeout > 0;
    if(control.rx_timeout_enabled) {
        dw3000_write_reg(inst, RX_FWTO_ID, 0, timeout, sizeof(uint32_t));
        /* set the RX FWTO bit */
        dw3000_modify_reg(inst, SYS_CFG_ID, 1, 0xff, SYS_CFG_RXWTOE_BIT_MASK>>8, sizeof(uint8_t));
    }else{
        control.on_error_continue_enabled = 1;
        /* clear the RX FWTO bit */
        dw3000_modify_reg(inst, SYS_CFG_ID, 1, ~(SYS_CFG_RXWTOE_BIT_MASK>>8), 0x0, sizeof(uint8_t));
    }

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

static uint16_t
calc_rx_window_timeout(uint64_t rx_start, uint64_t rx_end)
{
    uint32_t timeout = ((rx_end - rx_start) & UWB_DTU_40BMASK) >> 16;
    /* If more than 8.4s away (more than 1/2 period)- the end has likely
     * already passed so set a short timeout as to trigger a timeout */
    if (timeout > 0x7fffff) {
        timeout = 1;
    }
    /* DW3000 can't have a rx-timeout greater than 0xfffff */
    if (timeout > RX_FWTO_FWTO_BIT_MASK) {
        timeout = RX_FWTO_FWTO_BIT_MASK;
    }
    return timeout;
}

static uint32_t
update_rx_window_timeout(struct _dw3000_dev_instance_t * inst, uint64_t rel_start)
{
    uint32_t timeout = calc_rx_window_timeout(rel_start, inst->uwb_dev.abs_timeout);
    dw3000_adj_rx_timeout(inst, timeout);
    return timeout;
}

/**
 * Set Absolute rx start and end, in dtu
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param rx_start The future time at which the RX will start, in dwt timeunits (uwb usecs << 16).
 * @param rx_end   The future time at which the RX will end, in dwt timeunits.
 *
 * @return struct uwb_dev_status
 *
 * @brief Automatically adjusts the rx_timeout after each received frame to match dx_time_end
 */
struct uwb_dev_status
dw3000_set_rx_window(struct _dw3000_dev_instance_t * inst, uint64_t rx_start, uint64_t rx_end)
{
    uint16_t timeout;
    dw3000_set_delay_start(inst, rx_start);

    /* Calculate initial rx-timeout */
    timeout = calc_rx_window_timeout(rx_start, rx_end);
    inst->control.abs_timeout = 1;
    inst->uwb_dev.abs_timeout = rx_end;

    dw3000_set_rx_timeout(inst, timeout);
    return inst->uwb_dev.status;
}

/**
 * Set Absolute rx end, in dtu
 *
 * @param inst     Pointer to _dw3000_dev_instance_t.
 * @param rx_end   The future time at which the RX will end, in dwt timeunits.
 *
 * @return struct uwb_dev_status
 *
 * @brief Automatically adjusts the rx_timeout after each received frame to match dx_time_end.
 */
struct uwb_dev_status
dw3000_set_abs_timeout(struct _dw3000_dev_instance_t * inst, uint64_t rx_end)
{
    inst->control.abs_timeout = 1;
    inst->uwb_dev.abs_timeout = rx_end;
    return inst->uwb_dev.status;
}

/**
 * API to read the data from the Accumulator buffer, from an offset location give by offset parameter.
 *
 * NOTE: Because of an internal memory access delay when reading the accumulator the first octet output is a dummy octet
 *       that should be discarded. This is true no matter what sub-index the read begins at.
 *
 * @param inst            Pointer to _dw3000_dev_instance_t.
 * @param buffer          The buffer into which the data will be read.
 * @param accSampleIndex  The sample index in the acc buffer (NOTE:not byte index)
 * @param length          The length of data to read (in bytes).
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_read_accdata(struct _dw3000_dev_instance_t * inst, uint8_t *buffer, uint16_t accSampleIndex, uint16_t length)
{
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER); // Block if request pending
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    // Force on the ACC clocks if we are sequenced
    dw3000_phy_sysclk_ACC(inst, true);
    if(accSampleIndex <= REG_DIRECT_OFFSET_MAX_LEN) {
        /* Directly read data from the IC to the buffer */
        dw3000_read(inst, ACC_MEM_18B_ID, accSampleIndex, buffer, length) ;
    } else {
        /* Program the indirect offset registers B for specified offset to ACC */
        dw3000_write_reg(inst, INDIRECT_ADDR_A_ID, 0, (ACC_MEM_18B_ID >> 16), sizeof(uint32_t));
        dw3000_write_reg(inst, ADDR_OFFSET_A_ID, 0, accSampleIndex, sizeof(uint32_t));

        /* Indirectly read data from the IC to the buffer */
        dw3000_read(inst, INDIRECT_POINTER_A_ID, 0, buffer, length);
    }
    dw3000_phy_sysclk_ACC(inst, false);

    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}


/**
 * Enable frame filtering - (the default option is to
 * accept any data and ACK frames with correct destination address.
 *
 * @param inst     Pointer to structure _dw3000_dev_instance_t.
 * @param enable   Enables/disables the frame filtering for different frame types:
 *       DWT_FF_BEACON_EN            0x001           // beacon frames allowed
 *       DWT_FF_DATA_EN              0x002           // data frames allowed
 *       DWT_FF_ACK_EN               0x004           // ack frames allowed
 *       DWT_FF_MAC_EN               0x008           // mac control frames allowed
 *       DWT_FF_RSVD_EN              0x010           // reserved frame types allowed
 *       DWT_FF_MULTI_EN             0x020           // multipurpose frames allowed
 *       DWT_FF_FRAG_EN              0x040           // fragmented frame types allowed
 *       DWT_FF_EXTEND_EN            0x080           // extended frame types allowed
 *       DWT_FF_COORD_EN             0x100           // behave as coordinator (can receive frames with no dest address (PAN ID has to match))
 *       DWT_FF_IMPBRCAST_EN         0x200           // allow MAC implicit broadcast
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_mac_framefilter(struct _dw3000_dev_instance_t * inst, uint16_t enable)
{
    inst->uwb_dev.config.rx.frameFilter = enable;
    if(enable > 0) {
        /* Enable frame filtering and configure frame types */
        dw3000_modify_reg(inst, SYS_CFG_ID, 0,
                          0xff, SYS_CFG_FFEN_BIT_MASK, sizeof(uint8_t));
        dw3000_write_reg(inst, ADR_FILT_CFG_ID, 0, enable, sizeof(uint16_t));
    } else {
        /* Disable frame filter */
        dw3000_modify_reg(inst, SYS_CFG_ID, 0,
                          (uint8_t)(~(SYS_CFG_FFEN_BIT_MASK)), 0, sizeof(uint8_t));
        dw3000_write_reg(inst, ADR_FILT_CFG_ID, 0, 0x0000, sizeof(uint16_t));
    }

    return inst->uwb_dev.status;
}

/**
 * Enable the auto-ACK feature.
 * NOTE: needs to have frame filtering enabled as well.
 *
 * @param inst    Pointer to _dw3000_dev_instance_t.
 * @param enable  Enable / disable the auto-ack feature
 * @return struct uwb_dev_status
 */
struct uwb_dev_status
dw3000_set_autoack(struct _dw3000_dev_instance_t * inst, bool enable)
{
    if (enable) {
        /* set the AUTO_ACK bit */
        dw3000_modify_reg(inst, SYS_CFG_ID, 0,
                         0xffff, SYS_CFG_AUTO_ACK_BIT_MASK, sizeof(uint16_t));
    } else {
        /* clear the AUTO_ACK bit */
        dw3000_modify_reg(inst, SYS_CFG_ID, 0,
                          (uint16_t)(~SYS_CFG_AUTO_ACK_BIT_MASK), 0, sizeof(uint16_t));
    }

    return inst->uwb_dev.status;
}

/**
 * Set the auto-ACK delay. If the delay (parameter) is 0, the ACK will
 * be sent as-soon-as-possable
 * otherwise it will be sent with a programmed delay (in preamble symbols), max is 255.
 * NOTE: needs to have frame filtering enabled as well.
 *
 * @param inst   Pointer to _dw3000_dev_instance_t.
 * @param delay  If non-zero the ACK is sent after this delay, max is 255.
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status
dw3000_set_autoack_delay(struct _dw3000_dev_instance_t * inst, uint8_t delay)
{
    /* Set auto ACK reply delay in symbols (~1us) */
    dw3000_write_reg(inst, ACK_RESP_ID, 3, delay, sizeof(uint8_t));
    dw3000_set_autoack(inst, true);

    return inst->uwb_dev.status;
}


/**
 * Wait-for-Response turn-around Time. This 20-bit field is used to configure the turn-around time between TX complete
 * and RX enable when the wait for response function is being used. This function is enabled by the WAIT4RESP control in
 * Register file: 0x0D  System Control Register. The time specified by this W4R_TIM parameter is in units of approximately 1 s,
 * or 128 system clock cycles. This configuration may be used to save power by delaying the turn-on of the receiver,
 * to align with the response time of the remote system, rather than turning on the receiver immediately after transmission completes.
 *
 * @param inst   Pointer to _dw3000_dev_instance_t.
 * @param delay  The delay is in UWB microseconds.
 *
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status
dw3000_set_wait4resp_delay(struct _dw3000_dev_instance_t * inst, uint32_t delay)
{
    uint32_t ack_resp_reg;
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER); // Block if request pending
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    /* Read ACK_RESP_T_ID register */
    ack_resp_reg = dw3000_read_reg(inst, ACK_RESP_ID, 0, sizeof(uint32_t));

    inst->control.wait4resp_delay_enabled = delay > 0;
    /* We only need to write to the register if we're setting a new delay or
     * clearing an existing one */
    if (inst->control.wait4resp_delay_enabled || (ack_resp_reg&ACK_RESP_WAIT4RESP_TIM_BIT_MASK)) {
        ack_resp_reg &= ~(ACK_RESP_WAIT4RESP_TIM_BIT_MASK) ;        // Clear the timer (19:0)
        ack_resp_reg |= (delay & ACK_RESP_WAIT4RESP_TIM_BIT_MASK) ; // In UWB microseconds (e.g. turn the receiver on delay uus after TX)
        dw3000_write_reg(inst, ACK_RESP_ID, 0, ack_resp_reg, sizeof(uint32_t));
    }
    err = dpl_mutex_release(&inst->mutex);
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}


/**
 * API to enable the double receive buffer mode.
 *
 * @param inst    Pointer to _dw3000_dev_instance_t.
 * @param enable  1 to enable, 0 to disable the double buffer mode.
 *
 * @return struct uwb_dev_status
 *
 */
struct uwb_dev_status
dw3000_set_dblrxbuff(struct _dw3000_dev_instance_t * inst, bool enable)
{
    dpl_error_t err = dpl_mutex_pend(&inst->mutex,  DPL_TIMEOUT_NEVER); // Block if request pending
    if (err != DPL_OK) {
        inst->uwb_dev.status.mtx_error = 1;
        goto mtx_error;
    }

    inst->uwb_dev.config.dblbuffon_enabled = enable;
    if(inst->uwb_dev.config.dblbuffon_enabled) {
        /* Enable double rx buffer by clearing the disable double-buffer mode bit */
        dw3000_modify_reg(inst, SYS_CFG_ID, 0, (uint8_t)(~SYS_CFG_EN_DRXB_BIT_MASK), 0x0, sizeof(uint8_t));
        inst->uwb_dev.status.dblbuff_current = DBL_BUFF_ACCESS_BUFFER_A;
    } else {
        dw3000_modify_reg(inst, SYS_CFG_ID, 0, 0xff, SYS_CFG_EN_DRXB_BIT_MASK, sizeof(uint8_t));
        inst->uwb_dev.status.dblbuff_current = DBL_BUFF_OFF;
    }

    err = dpl_mutex_release(&inst->mutex);       // Read modify write critical section exit
    assert(err == DPL_OK);
mtx_error:
    return inst->uwb_dev.status;
}

/**
 * @fn dw3000_toggle_rx_buff()
 *
 * @brief This API sends issues a command to the device that the specific RX buff is free for frame reception,
 * it will also update the dblbuffon flag/status to the next buffer
 *
 * input parameters
 * @param inst Pointer to struct _dw3000_dev_instance_t
 *
 * output parameters
 *
 * no return value
 */
void dw3000_toggle_rx_buff(struct _dw3000_dev_instance_t * inst)
{
    dw3000_write_fast_CMD(inst, CMD_DB_TOGGLE);

    /* update the status register */
    if (inst->uwb_dev.status.dblbuff_current == DBL_BUFF_ACCESS_BUFFER_B) {
        inst->uwb_dev.status.dblbuff_current = DBL_BUFF_ACCESS_BUFFER_A;
    } else {
        inst->uwb_dev.status.dblbuff_current = DBL_BUFF_ACCESS_BUFFER_B;
    }
}


/**
 * API for reading carrier integrator value
 *
 * @brief This is used to read the RX carrier integrator value
 * (relating to the frequency offset of the TX node)
 *
 * NOTE: This is a 21-bit signed quantity, the function sign extends the most
 *       significant bit, which is bit #20 (numbering from bit zero) to return
 *       a 32-bit signed integer value.
 *
 * @param inst          Pointer to _dw3000_dev_instance_t.
 *
 * @return int32_t the signed carrier integrator value.
 *                 A positive value means the local RX clock is running faster than the remote TX device.
 */
int32_t
dw3000_read_carrier_integrator(struct _dw3000_dev_instance_t * inst)
{
#define B20_SIGN_EXTEND_TEST (0x00100000UL)
#define B20_SIGN_EXTEND_MASK (0xFFF00000UL)
#define DRX_CARRIER_INT_LEN  (3)
    uint32_t  regval=0;
    /* Read 3 bytes (21-bit quantity) */
    regval = dw3000_read_reg(inst, DRX_DIAG3_ID, 0, DRX_CARRIER_INT_LEN);

    /* Check for a negative number */
    if (regval & B20_SIGN_EXTEND_TEST) {
        /* sign extend bit #20 to whole word */
        regval |= B20_SIGN_EXTEND_MASK;
    } else {
        /* make sure upper bits are clear if not sign extending */
        regval &= DRX_DIAG3_CAR_INT_BIT_MASK;
    }
    /* cast unsigned value to signed quantity */
    return (int32_t) regval;
}

/**
 * API for calculating the clock offset ratio from the carrior integrator value
 *
 * @param inst Pointer to _dw3000_dev_instance_t.
 * @param integrator_val carrier integrator value
 *
 * @return float   the relative clock offset ratio
 */
dpl_float64_t
dw3000_calc_clock_offset_ratio(struct _dw3000_dev_instance_t * inst, int32_t integrator_val)
{
    dpl_float64_t ccor;
    dpl_float64_t fom = DPL_FLOAT64_INIT(DWT_FREQ_OFFSET_MULTIPLIER);
    dpl_float64_t hz_to_ppm;

    switch ( inst->uwb_dev.config.channel ) {
    case 5: hz_to_ppm = DPL_FLOAT64_INIT(DWT_HZ_TO_PPM_MULTIPLIER_CHAN_5);break;
    case 9: hz_to_ppm = DPL_FLOAT64_INIT(DWT_HZ_TO_PPM_MULTIPLIER_CHAN_9);break;
    default: assert(0);
    }
    ccor = DPL_FLOAT64_MUL(DPL_FLOAT64_I32_TO_F64(integrator_val), DPL_FLOAT64_MUL(fom, hz_to_ppm));
    ccor = DPL_FLOAT64_DIV(ccor, DPL_FLOAT64_INIT(1.0e6));
    return ccor;
}

/**
 * API for calculating the clock offset ratio from the time tracking offset
 *
 * @param inst Pointer to _dw3000_dev_instance_t.
 * @param ttcko Time Tracking Clock Offset
 *
 * @return float   the relative clock offset ratio
 */
dpl_float64_t
dw3000_calc_clock_offset_ratio_ttco(struct _dw3000_dev_instance_t * inst, int32_t ttcko)
{
    int32_t denom = 0x01F00000;
    /* TODO: Is the prf updated still since this is controlled by rx/tx codes? */
    if (inst->uwb_dev.config.prf != DWT_PRF_16M) {
        denom = 0x01FC0000;
    }
    return DPL_FLOAT64_DIV(DPL_FLOAT64_I32_TO_F64(-ttcko), DPL_FLOAT64_I32_TO_F64(denom));
}

/**
 * @fn dw3000_read_sts_quality()
 * @brief this function reads the cipher preamble (CP) signal quality index
 *
 * Note: For the 64 MHz PRF if value is >= 90% of the CP length then we can assume good CP reception.
 *       For the 16 MHz PRF value >= 75% of the CP length is considered good.
 *       Otherwise the CP timestamp may not be accurate.
 *
 * @param inst          Pointer to _dw3000_dev_instance_t.
 * @param sts_qual_idx  Sts quality index, raw value
 * @return value >=0 for good and < 0 if bad CP quality.
 */
int
dw3000_read_sts_quality(struct _dw3000_dev_instance_t * inst, int16_t *sts_qual_idx)
{
    uint16_t preambleCount;

    /* read CP preamble count value */
    preambleCount = dw3000_read_reg(inst, CP_STS_ID, 0, sizeof(uint16_t)) & CP_STS_ACC_QUAL_BIT_MASK;

    if(preambleCount & CP_ACC_CP_QUAL_SIGNTST) {
        preambleCount |= CP_ACC_CP_QUAL_SIGNEXT;
    }

    if (sts_qual_idx) {
        *sts_qual_idx = (int16_t) preambleCount;
    }
    /* determine if the CP Rx quality is good or bad
     * (return >=0 for good and < 0 if bad) */
    return (int)((int16_t)preambleCount - inst->sts_threshold);
}

/**
 * Helper function mapping reads to correct spot in dw3000 depending
 * on if double buffring is used and if so which buffer is active. */
static void
_read_rxdiag_pdoa_tdoa(struct _dw3000_dev_instance_t * inst, struct _dw3000_dev_rxdiag_t * diag)
{
    const uint64_t mask41 = 0x1FFFFFFFFFFULL;
    const uint32_t mask14 = 0x3FFF;
    uint32_t id, tdoa_o, pdoa_o;

    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */

        id = INDIRECT_POINTER_B_ID;
        tdoa_o = BUF1_CIA_TDOA0 - BUF1_FINFO;
        pdoa_o = BUF1_CIA_PDOA_TDOA1 + 2 - BUF1_FINFO;
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        id = BUF0_FINFO;
        tdoa_o = BUF0_CIA_TDOA0 - BUF0_FINFO;
        pdoa_o = BUF0_CIA_PDOA_TDOA1 + 2 - BUF0_FINFO;
        break;
    default:
        id = CIA_TDOA_0_ID;
        tdoa_o = 0;
        pdoa_o = CIA_TDOA_1_PDOA_ID + 2 - CIA_TDOA_0_ID;
        break;
    }

    /* timestamp difference of the 2 sts RX timestamps */
    diag->tdoa = dw3000_read_reg(inst, id, tdoa_o, 6) & mask41;
    /* phase difference of the 2 sts POAs (signed in [1:-11]) */
    diag->pdoa = dw3000_read_reg(inst, id, pdoa_o, sizeof(uint16_t)) & mask14;
    if (diag->pdoa & 0x2000) diag->pdoa |= 0xC000; //sign extend
}


static void
_read_rxdiag_rxt(struct _dw3000_dev_instance_t * inst, struct _dw3000_dev_rxdiag_t * diag, uint16_t en)
{
    uint8_t b[24], length = 24;
    uint32_t read_id, offset;
    const uint64_t mask40 = 0xFFFFFFFFFFULL;

    /* It doesn't make sense to read separate timestamps if there's only ipatov */
    if (inst->uwb_dev.config.rx.stsMode == DWT_STS_MODE_OFF) {
        return;
    }

    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* IP_TOA_LO_ID marks the start */
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */
        read_id = INDIRECT_POINTER_B_ID;
        offset = BUF1_ipTOA0 - BUF1_FINFO;
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        read_id = BUF0_ipTOA0;
        offset = 0;
        break;
    default:
        read_id = IP_TOA_LO_ID;
        offset = 0;
        break;
    }

    dw3000_read(inst, read_id, offset, b, length);

    diag->ipatovRxTime     = (*(uint64_t*)&b[0]) & mask40; // RX timestamp from Ipatov sequence
    diag->ipatovPOA        = (*(uint64_t*)&b[5]);          // Phase of arrival as computed from the Ipatov CIR (signed rad*2-12)
    diag->ipatovRxStatus   = b[7];                         // RX status info for Ipatov sequence
    diag->rxd.valid |= UWB_RXDIAG_IPATOV_RXTIME;

    if (en & UWB_RXDIAG_STS_RXTIME) {
        diag->stsRxTime     = (*(uint64_t*)&b[8]) & mask40; // RX timestamp from Ipatov sequence
        diag->stsPOA        = (*(uint64_t*)&b[13]);         // Phase of arrival as computed from the Ipatov CIR (signed rad*2-12)
        diag->stsRxStatus   = b[15];                        // RX status info for Ipatov sequence
        if (!(en&UWB_RXDIAG_STS)) {
            /* If not reading the entire sts diag sequence, at least read the accumulated symbols */
            /* Number of accumulated symbols [11:0] for STS sequence */
            diag->sts.accumCount = dw3000_read_reg(inst, CY0_DIAG_12_ID, 0, sizeof(uint16_t)) & 0xFFF;
        }
        diag->rxd.valid |= UWB_RXDIAG_STS_RXTIME;
    }

    if (en & UWB_RXDIAG_STS2_RXTIME) {
        diag->sts2RxTime     = (*(uint64_t*)&b[16]) & mask40; // RX timestamp from Ipatov sequence
        diag->sts2POA        = (*(uint64_t*)&b[21]);          // Phase of arrival as computed from the Ipatov CIR (signed rad*2-12)
        diag->sts2RxStatus   = b[23];                         // RX status info for Ipatov sequence
        if (!(en&UWB_RXDIAG_STS2)) {
            /* If not reading the entire sts2 diag sequence, at least read the accumulated symbols */
            /* Number of accumulated symbols [11:0] for STS sequence */
            diag->sts2.accumCount = dw3000_read_reg(inst, CY1_DIAG_12_ID, 0, sizeof(uint16_t)) & 0xFFF;
        }
        diag->rxd.valid |= UWB_RXDIAG_STS2_RXTIME;
    }
}

/**
 * Helper function mapping reads to correct spot in dw3000 depending
 * on if double buffring is used and if so which buffer is active.
 * param seq_id   0=Ipatov, 1=STS1, 2=STS2 */
static struct uwb_dev_status
_read_rxdiag_seq(struct _dw3000_dev_instance_t * inst, uint8_t seq_id,
                 struct dw3000_rxdiag_sequence *seq, uint16_t length)
{
    uint32_t read_id, offset = 0;
    assert(seq_id < 2);

    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* Assume these are setup properly in interrupt_ev_cb */
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */

        /* IP_TOA_LO_ID marks the start */
        read_id = INDIRECT_POINTER_B_ID;
        if (seq_id == 0) {
            offset = BUF1_ipDiag0 - BUF1_FINFO;
            /* ipDiag12 is named Ip_Nacc in dblrxbuff set */
            seq->accumCount = dw3000_read_reg(inst, read_id, BUF1_Ip_Nacc - BUF1_FINFO, 2);
            length -= 4;
        } else {
            offset = BUF1_cyDiag0 - BUF1_FINFO;
        }
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        read_id = BUF0_FINFO;
        if (seq_id == 0) {
            offset = BUF0_ipDiag0 - BUF0_FINFO;
            /* ipDiag12 is named Ip_Nacc in dblrxbuff set */
            seq->accumCount = dw3000_read_reg(inst, read_id, BUF0_Ip_Nacc - BUF0_FINFO, 2);
            length -= 4;
        } else {
            offset = BUF0_cyDiag0 - BUF0_FINFO;
        }
        break;
    default:
        offset = 0;
        read_id = IP_DIAG_0_ID;
        if (seq_id == 1) {
            /* CY0 is split over 0xC0000 and 0xD0000, read 0xD0000 section first */
            dw3000_read(inst, CY0_DIAG_4_ID, 0, (uint8_t*)(&seq->f3), length - (CY0_DIAG_3_ID - CY0_DIAG_0_ID + 4));
            length = (CY0_DIAG_3_ID - CY0_DIAG_0_ID + 4);
            read_id = CY0_DIAG_0_ID;
        }
        break;
    }

    return dw3000_read(inst, read_id, offset, (uint8_t*)seq, length);
}

/**
 * Helper function mapping reads to correct spot in dw3000 depending
 * on if double buffring is used and if so which buffer is active. */
static void
_read_rxdiag_xtal(struct _dw3000_dev_instance_t * inst, struct _dw3000_dev_rxdiag_t * diag)
{
    const uint32_t mask29 = 0x1FFFFFFF;
    const uint32_t mask13 = 0x1FFF;

    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */

        diag->xtalOffset = dw3000_read_reg(inst, INDIRECT_POINTER_B_ID,
                                           BUF1_CIA_DIAG0 - BUF1_FINFO,
                                           sizeof(uint16_t)) & mask13;
        diag->ciaDiag1 = dw3000_read_reg(inst, INDIRECT_POINTER_B_ID,
                                         BUF1_ciaDiag1 - BUF1_FINFO,
                                         sizeof(uint32_t)) & mask29;
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        /* timestamp difference of the 2 sts RX timestamps */
        diag->xtalOffset = dw3000_read_reg(inst, BUF0_CIA_DIAG0, 0, sizeof(uint16_t)) & mask13;
        diag->ciaDiag1 = dw3000_read_reg(inst, BUF0_ciaDiag1, 0, sizeof(uint32_t)) & mask29;
        break;
    default:
        /* timestamp difference of the 2 sts RX timestamps */
        diag->xtalOffset = dw3000_read_reg(inst, CIA_DIAG_0_ID, 0, sizeof(uint16_t)) & mask13;
        diag->ciaDiag1   = dw3000_read_reg(inst, CIA_DIAG_1_ID, 0, sizeof(uint32_t)) & mask29;
        break;
    }
}

/**
 * API to read the RX signal quality diagnostic data.
 *
 * @param inst          Pointer to _dw3000_dev_instance_t.
 * @param diag          Diagnostic structure pointer, this will contain the diagnostic data read from the DW3000.
 * @param en            Bitfield of enabled diagnostics to read out
 * @return void
 */
void
dw3000_read_rxdiag(struct _dw3000_dev_instance_t * inst, struct _dw3000_dev_rxdiag_t * diag, uint16_t en)
{
    const uint32_t mask31 = 0x7FFFFFFF;
    const uint32_t mask22 = 0x3FFFFF;
    const uint32_t mask21 = 0x1FFFFF;
    const uint32_t mask17 = 0x1FFFF;
    const uint32_t mask16 = 0xFFFF;
    const uint32_t mask12 = 0xFFF;
    const uint32_t mask10 = 0x3FF;
    uint32_t tmp;

    if (en & (UWB_RXDIAG_IPATOV_RXTIME|UWB_RXDIAG_STS_RXTIME|UWB_RXDIAG_STS2_RXTIME)) {
        _read_rxdiag_rxt(inst, diag, en);
    }

    if (inst->uwb_dev.config.rx.stsMode != DWT_STS_MODE_OFF) {
        if ((en & UWB_RXDIAG_COMB_TPDOA) && (inst->uwb_dev.config.rx.pdoaMode != DWT_PDOA_M0)) {
            _read_rxdiag_pdoa_tdoa(inst, diag);
            diag->rxd.valid |= UWB_RXDIAG_COMB_TPDOA;
        }
    }

    if (en & UWB_RXDIAG_COMB_XTALO) {
        _read_rxdiag_xtal(inst, diag);
        diag->rxd.valid |= UWB_RXDIAG_COMB_XTALO;
    }

    /* Read sequence specific diagnostics */
    if (en&UWB_RXDIAG_IPATOV) {
        _read_rxdiag_seq(inst, 0, &diag->ipatov, sizeof(struct dw3000_rxdiag_sequence));
        diag->rxd.valid |= UWB_RXDIAG_IPATOV;
    }

    if (inst->uwb_dev.config.rx.stsMode != DWT_STS_MODE_OFF) {
        if (en&(UWB_RXDIAG_STS | UWB_RXDIAG_STS2)) {
            _read_rxdiag_seq(inst, 1, &diag->sts, 2*sizeof(struct dw3000_rxdiag_sequence) + 5*4);
            diag->rxd.valid |= UWB_RXDIAG_STS;
        }

        if (en&UWB_RXDIAG_STS2) {
            /* Already read as part of sts1 above */
            diag->rxd.valid |= UWB_RXDIAG_STS2;
        }
    }

    /* Mask the fields that need it */
    diag->ipatov.peak_union &= mask31;      // index [30:21] and amplitude [20:0] of peak sample in Ipatov sequence CIR
    tmp = diag->ipatov.peak_union;
    diag->ipatov.peak = tmp&mask21;
    diag->ipatov.peak_idx = (tmp >> 21) & mask10;
    diag->ipatov.power      &= mask17;      // channel area allows estimation [16:0] of channel power for the Ipatov sequence
    diag->ipatov.f1         &= mask22;      // F1 for Ipatov sequence [21:0]
    diag->ipatov.f2         &= mask22;      // F2 for Ipatov sequence [21:0]
    diag->ipatov.f3         &= mask22;      // F3 for Ipatov sequence [21:0]
    diag->ipatov.noiseMean  &= mask22;      // Noise Mean [21:0] for Ipatov sequence
    diag->ipatov.fpIndex    &= mask16;      // First path index [15:0] for Ipatov sequence
    diag->ipatov.threshold  &= mask22;      // Threshold [21:0] info for Ipatov sequence
    diag->ipatov.accumCount &= mask12;      // Number accumulated symbols [11:0] for Ipatov sequence
    //printf("db[%x]:seq[%d] p%ld a%d\n", inst->uwb_dev.status.dblbuff_current, 0, diag->ipatov.power, diag->ipatov.accumCount);

    /* Mask the fields that need it */
    diag->sts.peak_union &= mask31;         // index [30:21] and amplitude [20:0] of peak sample in sequence CIR
    tmp = diag->sts.peak_union;
    diag->sts.peak = tmp&mask21;
    diag->sts.peak_idx = (tmp >> 21) & mask10;
    diag->sts.power      &= mask16;         // channel area allows estimation [15:0] of channel power for the sequence
    diag->sts.f1         &= mask22;         // F1 for sequence [21:0]
    diag->sts.f2         &= mask22;         // F2 for sequence [21:0]
    diag->sts.f3         &= mask22;         // F3 for sequence [21:0]
    diag->sts.noiseMean  &= mask22;         // Noise Mean [21:0] for sequence
    diag->sts.fpIndex    &= mask16;         // First path index [15:0] for sequence
    diag->sts.threshold  &= mask22;         // Threshold [21:0] info for sequence
    diag->sts.accumCount &= mask12;         // Number accumulated symbols [11:0] for sequence
    //printf("db[%x]:seq[%d] p%ld a%d\n", inst->uwb_dev.status.dblbuff_current, 1, diag->sts.power, diag->sts.accumCount);

    /* Mask the fields that need it */
    diag->sts2.peak_union &= mask31;        // index [30:21] and amplitude [20:0] of peak sample in sequence CIR
    tmp = diag->sts2.peak_union;
    diag->sts2.peak = tmp&mask21;
    diag->sts2.peak_idx = (tmp >> 21) & mask10;
    diag->sts2.power      &= mask16;        // channel area allows estimation [15:0] of channel power for the sequence
    diag->sts2.f1         &= mask22;        // F1 for sequence [21:0]
    diag->sts2.f2         &= mask22;        // F2 for sequence [21:0]
    diag->sts2.f3         &= mask22;        // F3 for sequence [21:0]
    diag->sts2.noiseMean  &= mask22;        // Noise Mean [21:0] for sequence
    diag->sts2.fpIndex    &= mask16;        // First path index [15:0] for sequence
    diag->sts2.threshold  &= mask22;        // Threshold [21:0] info for sequence
    diag->sts2.accumCount &= mask12;        // Number accumulated symbols [11:0] for sequence
    //printf("db[%x]:seq[%d] p%ld a%d\n", inst->uwb_dev.status.dblbuff_current, 2, diag->sts2.power, diag->sts2.accumCount);
}

/**
 * The DW3000 processing of interrupts in a task context instead of the interrupt context such that other interrupts
 * and high priority tasks are not blocked waiting for the interrupt handler to complete processing.
 * This dw3000 softstack needs to coexists with other stacks and sensors interfaces. Use directive DW3000_DEV_TASK_PRIO to defined
 * the priority of the dw3000_softstack at compile time.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return void
 */
void
dw3000_tasks_init(struct _dw3000_dev_instance_t * inst)
{
    /* Check if the tasks are already initiated */
    if (!dpl_eventq_inited(&inst->uwb_dev.eventq))
    {
        /* Initialise task structures in uwb_dev */
        uwb_task_init(&inst->uwb_dev, dw3000_interrupt_ev_cb);

        /* Enable pull-down on IRQ to not get spurious interrupts when dw3000 is sleeping */
        hal_gpio_irq_init(inst->irq_pin, dw3000_irq, inst, HAL_GPIO_TRIG_RISING, HAL_GPIO_PULL_DOWN);
        hal_gpio_irq_enable(inst->irq_pin);
    }

    /* Setup interrupt mask
     * XXX TODO: We should really be writing exactly what we want in this register
     * rather than modifying it. */
    inst->sys_status_mask = SYS_STATUS_CLK_PLL_LOCK_BIT_MASK |
        SYS_STATUS_TXFRB_BIT_MASK | SYS_STATUS_TXFRS_BIT_MASK |     /* TX */
        SYS_STATUS_RXFCG_BIT_MASK | SYS_STATUS_CIAERR_BIT_MASK |    /* RX */
        SYS_STATUS_ALL_RX_TO | SYS_STATUS_ALL_RX_ERR;               /* Errors */
    inst->sys_status_mask |= ((uint64_t)SYS_STATUS_HI_SPI_ERR)<<32; /* Hi errors */

    dw3000_phy_interrupt_mask(inst, inst->sys_status_mask, false);
    dw3000_write_fast_CMD(inst, CMD_CLR_IRQS);
    dw3000_phy_interrupt_mask(inst, inst->sys_status_mask, true);
    /* Read back results */
    inst->sys_status_mask = dw3000_read_reg(inst, SYS_ENABLE_LO_ID, 0, sizeof(uint64_t));
}


/**
 * API for the interrupt request.
 *
 * @param arg  Pointer to the queue of interrupts.
 * @return void
 */
static void
dw3000_irq(void *arg)
{
    dw3000_dev_instance_t * inst = arg;
    inst->uwb_dev.irq_at_ticks = dpl_cputime_get32();
    if (!inst->uwb_dev.status.sleeping) {
        dpl_eventq_put(&inst->uwb_dev.eventq, &inst->uwb_dev.interrupt_ev);
    }
}


/**
 * This is the DW3000's general Interrupt Service Routine. It will process/report the following events:
 *          - RXFCG (through rx_complete_cb callback)
 *          - TXFRS (through tx_complete_cb callback)
 *          - RXRFTO/RXPTO (through rx_timeout_cb callback)
 *          - RXPHE/RXFCE/RXRFSL/RXSFDTO/AFFREJ/LDEERR (through rx_error_cb cbRxErr)
 * For all events, corresponding interrupts are cleared and necessary resets are performed. In addition, in the RXFCG case,
 * received frame information and frame control are read before calling the callback. If double buffering is activated, it
 * will also toggle between reception buffers once the reception callback processing has ended.
 *
 * @param ev  Pointer to the queue of events.
 * @return void
 *
 */
static void
dw3000_interrupt_ev_cb(struct dpl_event *ev)
{
    uint16_t finfo;
    uint32_t rdb_status = 0;
    struct uwb_mac_interface * cbs;
    uint8_t rx_sp3;
    dw3000_dev_instance_t * inst = dpl_event_get_arg(ev);
    dpl_error_t err = dpl_sem_pend(&inst->uwb_dev.irq_sem,  DPL_TIMEOUT_NEVER);
    if (err != DPL_OK) {
        inst->uwb_dev.status.sem_error = 1;
        goto sem_error_exit;
    }

    /* Read status register */
#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
    {
        uint32_t irq_utime = dpl_cputime_get32();
#endif
        inst->sys_status = dw3000_read_reg(inst, SYS_STATUS_ID, 0, sizeof(uint32_t));
        inst->sys_status_hi = 0;
        /* Check for higher status bits only if needed */
        if (!(inst->sys_status&SYS_STATUS_LO_ALL)) {
            inst->sys_status_hi = dw3000_read_reg(inst, SYS_STATUS_HI_ID, 0, sizeof(uint16_t));
            if (!inst->sys_status_hi) {
                /* Empty status vector received. The CIA may block access to registers
                 * whist processing incoming frame, try re-reading. */
                MAC_STATS_INC(empty_irq);
                dpl_cputime_delay_usecs(30);
                inst->sys_status = dw3000_read_reg(inst, SYS_STATUS_ID, 0, sizeof(uint32_t));
                inst->sys_status_hi = dw3000_read_reg(inst, SYS_STATUS_HI_ID, 0, sizeof(uint16_t));
            }
        }

        if (inst->uwb_dev.status.dblbuff_current != DBL_BUFF_OFF) {
            rdb_status = dw3000_read_reg(inst, RDB_STATUS_ID, 0, sizeof(uint8_t));
            /* Translate doublebuffer status into normal status */
            if (inst->uwb_dev.status.dblbuff_current == DBL_BUFF_ACCESS_BUFFER_B) {
                /* If accessing the second buffer (RX_BUFFER_B) then
                 * use the second nibble of the DB status reg */
                rdb_status >>= 4;
            }
            if (rdb_status & RDB_STATUS_RXFCG0_BIT_MASK)   inst->sys_status |= SYS_STATUS_RXFCG_BIT_MASK;
            if (rdb_status & RDB_STATUS_RXFR0_BIT_MASK)    inst->sys_status |= SYS_STATUS_RXFR_BIT_MASK;
            if (rdb_status & RDB_STATUS_CIADONE0_BIT_MASK) inst->sys_status |= SYS_STATUS_CIA_DONE_BIT_MASK;
        }

#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
        if(!inst->sys_status_bt_lock) {
            DW3000_SYS_STATUS_BT_ADD(inst, inst->sys_status, irq_utime);
#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_HI)
            DW3000_SYS_STATUS_BT_HI(inst, inst->sys_status_hi);
#endif
        }
    }
#endif

    // Set status flags
    inst->uwb_dev.status.rx_error = (inst->sys_status & SYS_STATUS_ALL_RX_ERR) !=0;
    inst->uwb_dev.status.rx_timeout_error = (inst->sys_status & SYS_STATUS_ALL_RX_TO) !=0;
    inst->uwb_dev.status.lde_error = (inst->sys_status & SYS_STATUS_CIA_DONE_BIT_MASK) == 0;
    inst->uwb_dev.status.overrun_error = (inst->sys_status & SYS_STATUS_RXOVRR_BIT_MASK) != 0;
    inst->uwb_dev.status.autoack_triggered = (inst->sys_status & SYS_STATUS_AAT_BIT_MASK) != 0;
    inst->uwb_dev.status.sts_pream_error = (inst->sys_status & SYS_STATUS_CPERR_BIT_MASK) != 0;
    inst->uwb_dev.status.spi_error = (inst->sys_status_hi & SYS_STATUS_HI_SPI_ERR) != 0;
    inst->uwb_dev.status.spi_w_error = (inst->sys_status & SYS_STATUS_SPICRCERR_BIT_MASK) != 0;
    inst->uwb_dev.status.cmd_error = (inst->sys_status_hi & SYS_STATUS_HI_CMD_ERR_BIT_MASK) != 0;
    inst->uwb_dev.status.aes_error = (inst->sys_status_hi & SYS_STATUS_HI_AES_ERR_BIT_MASK) != 0;
    inst->uwb_dev.status.rx_prej = (inst->sys_status_hi & SYS_STATUS_HI_RXPREJ_BIT_MASK) != 0;
    inst->uwb_dev.status.pll_ll_error = (inst->sys_status & SYS_STATUS_CLK_PLL_LOCK_BIT_MASK) != 0;
    rx_sp3 = (inst->sys_status & SYS_STATUS_CIA_DONE_BIT_MASK) != 0 &&
        ((inst->uwb_dev.config.rx.stsMode & DWT_STS_MODE_ND) == DWT_STS_MODE_ND);

    if(dpl_sem_get_count(&inst->tx_sem) == 0){
        err = dpl_sem_release(&inst->tx_sem);
        assert(err == DPL_OK);
    }

      // leading edge detection complete
    if((inst->sys_status & SYS_STATUS_RXFCG_BIT_MASK) || rx_sp3) {
        MAC_STATS_INC(DFR_cnt);

        switch (inst->uwb_dev.status.dblbuff_current) {
        case DBL_BUFF_ACCESS_BUFFER_B:
            /* clear DB status register bits corresponding to RX_BUFFER_B */
            dw3000_write_reg(inst, RDB_STATUS_ID, 0, 0x70, sizeof(uint8_t));
            /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint8_t)); */
            /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint16_t)); */
            finfo = dw3000_read_reg(inst, INDIRECT_POINTER_B_ID, 0, sizeof(uint16_t));
            break;
        case DBL_BUFF_ACCESS_BUFFER_A:
            /* clear DB status register bits corresponding to RX_BUFFER_A */
            dw3000_write_reg(inst, RDB_STATUS_ID, 0, 0x7, sizeof(uint8_t));
            finfo = dw3000_read_reg(inst, BUF0_FINFO, 0, sizeof(uint16_t));
            break;
        default:
            /* Read frame info - Only the first two bytes of the register are used here */
            finfo = dw3000_read_reg(inst, RX_FINFO_ID, 0, sizeof(uint16_t));
        }
        /* Clear all receive status bits */
        dw3000_write_reg(inst, SYS_STATUS_ID, 1, (inst->sys_status&SYS_STATUS_ALL_RX_GOOD)>>8, sizeof(uint8_t));

        /* Report frame length - Standard frame length up to 127,
         * extended frame length up to 1023 bytes */
        inst->uwb_dev.frame_len = (finfo & RX_FINFO_RXFLEN_BIT_MASK);

        /* Remove the two appended CRC bytes from frame if data is present */
        if (inst->uwb_dev.frame_len) inst->uwb_dev.frame_len -= 2;

        if (inst->uwb_dev.status.overrun_error) {
            MAC_STATS_INC(ROV_err);
            /* Overrun flag has been set */
            dw3000_write_reg(inst, SYS_STATUS_ID, 0, SYS_STATUS_RXOVRR_BIT_MASK, sizeof(uint32_t));
            dw3000_phy_forcetrxoff(inst);
            dw3000_phy_rx_reset(inst);
            if (inst->control.on_error_continue_enabled) {
                dw3000_write_fast_CMD(inst, CMD_RX);
            }
            goto early_exit;
        }

        // The DW1000 had a bug that render the hardware auto_enable feature useless when used in conjunction with the double buffering.
        // Consequently, we reenable the transeiver in the MAC-layer as early as possable. Note: The default behavior of MAC-Layer
        // is that the transceiver only returns to the IDLE state with a timeout event occured. The MAC-layer should otherwise reenable.

        if (inst->uwb_dev.config.rxauto_enable == 0 && inst->uwb_dev.config.dblbuffon_enabled) {
            if (inst->control.rxauto_disable == false && !inst->uwb_dev.status.autoack_triggered) {
                /* Reenable receiver */
                dw3000_write_fast_CMD(inst, CMD_RX);
                inst->uwb_dev.status.rx_restarted = 1;
            }
        }

        /* Read the whole frame */
        if (inst->uwb_dev.frame_len) {
            dw3000_read_rx(inst, inst->uwb_dev.rxbuf, 0,
                           (inst->uwb_dev.frame_len < inst->uwb_dev.rxbuf_size) ?
                           inst->uwb_dev.frame_len : inst->uwb_dev.rxbuf_size);
        }

        /* First two bytes are frame ctrl */
        inst->uwb_dev.fctrl = ((uint16_t)inst->uwb_dev.rxbuf[1]<<8) | inst->uwb_dev.rxbuf[0];

#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
        if(!inst->sys_status_bt_lock) {
            DW3000_SYS_STATUS_BT_FCTRL(inst, inst->uwb_dev.fctrl);
        }
#endif

        if (inst->uwb_dev.status.lde_error) {
            /* retest lde_error condition */
            inst->uwb_dev.status.lde_error = (
                dw3000_read_reg(inst, SYS_STATUS_ID, 1, sizeof(uint8_t)) &
                (SYS_STATUS_CIA_DONE_BIT_MASK >> 8)) == 0;
        }
        if (inst->uwb_dev.status.lde_error) {
            /* CIA error or CIA late */
            MAC_STATS_INC(LDE_err);
        }

        inst->uwb_dev.rxtimestamp = dw3000_read_rxtime(inst);
        if (inst->control.abs_timeout) {
            /* TODO: compensate for the framelength after the RMARKER */
            update_rx_window_timeout(inst, inst->uwb_dev.rxtimestamp);
        }

        /* Collect RX Frame Quality diagnositics
         * TODO: Augment with reading of relevant regs */
        inst->rxdiag.rxd.valid = 0;
        if(inst->uwb_dev.config.rxdiag_enable) {
            dw3000_read_rxdiag(inst, &inst->rxdiag, inst->rxdiag.rxd.enabled);
        }

        inst->uwb_dev.status.sts_ts_error = 0;
        if (inst->uwb_dev.config.rx.stsMode != DWT_STS_MODE_OFF) {
            /* This STS timestamp is invalid if the timestamps doesn't match
             * or if we don't have enough sts symbols accumulated */
            uint64_t I_ts = inst->uwb_dev.rxtimestamp;
            uint64_t S_ts = inst->rxdiag.stsRxTime;
            int cp_qual = dw3000_read_sts_quality(inst, &inst->rxdiag.sts_acc_qual);
            inst->rxdiag.sts_qual_idx = cp_qual;

            if (!(inst->uwb_dev.config.rxdiag_enable & (UWB_RXDIAG_STS_RXTIME|UWB_RXDIAG_STS))) {
                _read_rxdiag_rxt(inst, &inst->rxdiag, UWB_RXDIAG_STS_RXTIME);
            }

            inst->uwb_dev.status.sts_ts_error =
                ((I_ts > S_ts) ? (I_ts - S_ts) : (S_ts - I_ts)) > MYNEWT_VAL(UWB_STS_TS_MATCH_THRESHOLD) ||
                (cp_qual < 0);

            /* If pdoa is activated but value not read as part of rxdiag read it here */
            if (inst->uwb_dev.config.rx.pdoaMode != DWT_PDOA_M0 &&
                !(inst->uwb_dev.config.rxdiag_enable & (UWB_RXDIAG_COMB_TPDOA))) {
                _read_rxdiag_pdoa_tdoa(inst, &inst->rxdiag);
            }
        }

        // Toggle the Host side Receive Buffer Pointer
        if (inst->uwb_dev.config.dblbuffon_enabled) {
            inst->uwb_dev.status.overrun_error = dw3000_checkoverrun(inst);
            if (inst->uwb_dev.status.overrun_error == 0) {
                dw3000_toggle_rx_buff(inst);
            }else{
                MAC_STATS_INC(ROV_err);
                /* Overrun flag has been set */
                dw3000_write_reg(inst, SYS_STATUS_ID, 0, SYS_STATUS_RXOVRR_BIT_MASK, sizeof(uint32_t));
                dw3000_phy_forcetrxoff(inst);
                dw3000_phy_rx_reset(inst);
                if (inst->control.on_error_continue_enabled) {
                    dw3000_write_fast_CMD(inst, CMD_RX);
                    inst->uwb_dev.status.rx_restarted = 1;
                }
            }
        } else {
            // carrier_integrator only available while in single buffer mode. (true for 3000?)
            inst->uwb_dev.carrier_integrator = dw3000_read_carrier_integrator(inst);
#if MYNEWT_VAL(CIR_ENABLED)
            /* Call CIR complete callbacks if present */
            if(inst->uwb_dev.config.cir_enable || inst->control.cir_enable) {
                if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))) {
                    SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next) {
                        if (cbs != NULL && cbs->cir_complete_cb) {
                            if(cbs->cir_complete_cb((struct uwb_dev*)inst,cbs)) continue;
                        }
                    }
                }
                inst->control.cir_enable = false;
            }
#endif
            /* Clear status bits */
            dw3000_write_reg(inst, SYS_STATUS_ID, 0, SYS_STATUS_ALL_RX_GOOD, sizeof(uint32_t));
            if (inst->control.rxauto_disable == false){
                /* Reenable receiver */
                dw3000_write_fast_CMD(inst, CMD_RX);
                inst->uwb_dev.status.rx_restarted = 1;
            }
            inst->control.rxauto_disable = false;
        }

        // Call the corresponding frame services callback if present
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))) {
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next) {
                if (cbs != NULL && cbs->rx_complete_cb) {
                    if(cbs->rx_complete_cb((struct uwb_dev*)inst,cbs)) continue;
                }
            }
        }
    }

    if (inst->uwb_dev.status.sts_pream_error) {
        /* Clear associated flag */
        dw3000_write_reg(inst, SYS_STATUS_ID, 3,
                         (uint8_t)(SYS_STATUS_CPERR_BIT_MASK>>24),
                         sizeof(uint8_t));
        MAC_STATS_INC(STSPream_err);
    }

    // Handle TX Frame Begins
    if(inst->sys_status & SYS_STATUS_TXFRB_BIT_MASK) {
        /* Clear TXFRB flag */
        dw3000_write_reg(inst, SYS_STATUS_ID, 0,
                         (uint8_t)(inst->sys_status & SYS_STATUS_TXFRB_BIT_MASK),
                         sizeof(uint8_t));

        /* Call the corresponding callback if present */
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))) {
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next) {
                if (cbs!=NULL && cbs->tx_begins_cb) {
                    if(cbs->tx_begins_cb((struct uwb_dev*)inst,cbs)) break;
                }
            }
        }
    }

    // Handle TX confirmation event
    if(inst->sys_status & SYS_STATUS_TXFRS_BIT_MASK) {
        MAC_STATS_INC(TFG_cnt);
        /* Clear all TX events */
        dw3000_write_reg(inst, SYS_STATUS_ID, 0,
                         (uint8_t)(inst->sys_status & SYS_STATUS_ALL_TX),
                         sizeof(uint8_t));
        // In the case where this TXFRS interrupt is due to the automatic transmission of an ACK solicited by a response (with ACK request bit set)
        // that we receive through using wait4resp to a previous TX (and assuming that the IRQ processing of that TX has already been handled), then
        // we need to handle the IC issue which turns on the RX again in this situation (i.e. because it is wrongly applying the wait4resp after the
        // ACK TX).
        // See section "Transmit and automatically wait for response" in DW3000 User Manual

        if((inst->sys_status & SYS_STATUS_AAT_BIT_MASK) &&
           inst->control.wait4resp_enabled) {
            dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
            /* Reset in case we were late and a frame was already
             * being received */
            dw3000_phy_rx_reset(inst);
        }
        /* XXX TODO: Is this redundant, see earlier in same function */
        if(dpl_sem_get_count(&inst->tx_sem) == 0) {
            err = dpl_sem_release(&inst->tx_sem);
            assert(err == DPL_OK);
        }

#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
        if(!inst->sys_status_bt_lock) {
            /* Assuming the start_tx writes the fctrl at send time */
            DW3000_SYS_STATUS_BT_FCTRL(inst, inst->uwb_dev.fctrl);
        }
#endif

        /* Call the corresponding callback if present */
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))){
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next){
                if (cbs!=NULL && cbs->tx_complete_cb) {
                    if(cbs->tx_complete_cb((struct uwb_dev*)inst,cbs)) break;
                }
            }
        }
    }

    // leading edge detection complete
    if(inst->sys_status & SYS_STATUS_CIAERR_BIT_MASK) {
        MAC_STATS_INC(LDE_err);
        dw3000_write_reg(inst, SYS_STATUS_ID, 0, SYS_STATUS_CIAERR_BIT_MASK, sizeof(uint32_t));
    }

    // Handle frame reception/preamble detect timeout events
    if(inst->uwb_dev.status.rx_timeout_error) {
        MAC_STATS_INC(RTO_cnt);
        /* Clear RX timeout event bits and any early rx flags */
        dw3000_write_reg(inst, SYS_STATUS_ID, 0,
                         inst->sys_status&(SYS_STATUS_ALL_RX_TO | SYS_STATUS_ALL_RX_GOOD),
                         sizeof(uint32_t));

        if (inst->control.abs_timeout) {
            /* Absolute timeout active, reactivate receiver if there's still time left */
            uint64_t systime = dw3000_read_systime(inst);
            uint32_t new_timeout = calc_rx_window_timeout(systime, inst->uwb_dev.abs_timeout);
            if (new_timeout > 1) {
                dw3000_write_fast_CMD(inst, CMD_RX);
                dw3000_adj_rx_timeout(inst, new_timeout);
            } else {
                inst->control.abs_timeout = false;
            }
        }

        if (!inst->control.abs_timeout) {
            inst->control.cir_enable = false;
            inst->control.rxauto_disable = false;

            /* Call the corresponding frame services callback if present */
            if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))){
                SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next){
                    if (cbs!=NULL && cbs->rx_timeout_cb) {
                        if(cbs->rx_timeout_cb((struct uwb_dev*)inst,cbs)) continue;
                    }
                }
            }
        }
    }

    // Handle RX errors events
    if(inst->uwb_dev.status.rx_error) {
        MAC_STATS_INC(RX_err);

        /* Because of an issue with receiver restart after error conditions,
         * an RX reset must be applied after any error or timeout event to ensure
         * the next good frame's timestamp is computed correctly.
         * See section "RX Message timestamp" in DW3000 User Manual. */
        dw3000_write_reg(inst, SYS_STATUS_ID, 0, inst->sys_status&(SYS_STATUS_ALL_RX_ERR|SYS_STATUS_ALL_RX_GOOD),
                         sizeof(uint32_t)); // Clear RX error event bits

        if (inst->uwb_dev.config.dblbuffon_enabled && inst->uwb_dev.status.overrun_error) {
            MAC_STATS_INC(ROV_err);
        } else {
            dw3000_phy_forcetrxoff(inst);
        }

        /* Restart the receiver even if rxauto is not enabled. Timeout remain active if set.
         * NOTE: Because we reset the receiver explicitly above we will need to reenable
         * the receiver even though the auto-enable is on. */
        dw3000_write_fast_CMD(inst, CMD_RX);
        if (inst->control.abs_timeout) {
            update_rx_window_timeout(inst, dw3000_read_systime(inst));
        }

        /* Call the corresponding frame services callback if present */
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))){
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next){
                if (cbs!=NULL && cbs->rx_error_cb) {
                    if(cbs->rx_error_cb((struct uwb_dev*)inst,cbs)) continue;
                }
            }
        }
    }

    /* Clear any HI / SPI errors */
    if (inst->uwb_dev.status.spi_error || inst->uwb_dev.status.cmd_error) {
        if (inst->uwb_dev.status.cmd_error) MAC_STATS_INC(FCMD_err);
        if (inst->uwb_dev.status.spi_error) MAC_STATS_INC(SPI_err);

        /* Reset by issuing a TXRXOFF and clear all IRQs */
        dw3000_write_fast_CMD(inst, CMD_TXRXOFF);
        dw3000_write_fast_CMD(inst, CMD_CLR_IRQS);

        /* Call the corresponding frame services callbacks if present */
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))) {
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next) {
                if (cbs!=NULL && cbs->reset_cb) {
                    if (cbs->reset_cb((struct uwb_dev*)inst, cbs)) continue;
                }
                if (cbs!=NULL && cbs->rx_error_cb) {
                    if (cbs->rx_error_cb((struct uwb_dev*)inst,cbs)) continue;
                }
                if (cbs!=NULL && cbs->tx_error_cb) {
                    if (cbs->tx_error_cb((struct uwb_dev*)inst,cbs)) continue;
                }
            }
        }
    }

    /* Clearing SPI CRC Error */
    if (inst->uwb_dev.status.spi_w_error) {
        dw3000_write_reg(inst, SYS_STATUS_ID, 0, SYS_STATUS_SPICRCERR_BIT_MASK, sizeof(uint32_t));
    }

    if (inst->uwb_dev.status.pll_ll_error) {
        MAC_STATS_INC(PLL_LL_err);
        dw3000_write_reg(inst, SYS_STATUS_ID, 0,
                         SYS_STATUS_CLK_PLL_LOCK_BIT_MASK,
                         sizeof(uint32_t));

        /* If this wasn't a result of returning from sleep, issue an rx_error */
        if (!(inst->sys_status & SYS_STATUS_RCINIT_BIT_MASK)) {
            if (!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))) {
                SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next) {
                    if (cbs!=NULL && cbs->pll_ll_cb) {
                        if (cbs->pll_ll_cb((struct uwb_dev*)inst,cbs)) continue;
                    }
                }
            }
        }
    }

    // Handle sleep timer event
    if(inst->sys_status & (SYS_STATUS_RCINIT_BIT_MASK|
                           SYS_STATUS_SPIRDY_BIT_MASK)) {
        /* Clear all these bits */
        dw3000_write_reg(inst, SYS_STATUS_ID, 0,
                         (SYS_STATUS_RCINIT_BIT_MASK|
                          SYS_STATUS_SPIRDY_BIT_MASK), sizeof(uint32_t));

        // restore antenna delay value, these are not preserved during sleep/deepsleep */
        dw3000_phy_set_rx_antennadelay(inst, inst->uwb_dev.rx_antenna_delay);
        dw3000_phy_set_tx_antennadelay(inst, inst->uwb_dev.tx_antenna_delay);

        // Call the corresponding callback if present
        inst->uwb_dev.status.sleeping = 0;
        if(!(SLIST_EMPTY(&inst->uwb_dev.interface_cbs))){
            SLIST_FOREACH(cbs, &inst->uwb_dev.interface_cbs, next){
                if (cbs!=NULL && cbs->sleep_cb) {
                    if (cbs->sleep_cb((struct uwb_dev*)inst,cbs)) continue;
                }
            }
        }
    }

early_exit:
    dpl_sem_release(&inst->uwb_dev.irq_sem);
sem_error_exit:
    /* Check for possibly missed interrupts occuring whilst we were looking at this one
     * NOTE: Because the interrupt is edge based we will only register an event if the irq pin
     * goes low and then comes back up. If the pin is high now and no event is queued just after
     * swapping rx-buffers this means we didn't have time to finish reading the data
     * from the previous irq until a new one arrived -> queue another irq event for the task */
    if (hal_gpio_read(inst->irq_pin) && !dpl_event_is_queued(ev)) {
        dpl_eventq_put(&inst->uwb_dev.eventq, &inst->uwb_dev.interrupt_ev);
#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
        if(!inst->sys_status_bt_lock) {
            DW3000_SYS_STATUS_BT_PTR(inst).interrupt_reentry = 1;
        }
#endif
    }

#if MYNEWT_VAL(DW3000_SYS_STATUS_BACKTRACE_LEN)
    if(!inst->sys_status_bt_lock) {
        DW3000_SYS_STATUS_BT_PTR(inst).utime_end = dpl_cputime_get32();
    }
#endif
}

/**
 * API to calculate First Path Power Level (fppl) from an rxdiag sequence
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 * @param seq   Pointer to struct dw3000_rxdiag_sequence
 *
 * @return fppl on success, nan otherwise
 */
dpl_float32_t
dw3000_calc_fppl(struct _dw3000_dev_instance_t * inst,
                 struct dw3000_rxdiag_sequence * seq)
{
    dpl_float32_t A, N, v, fppl;

    if (seq->accumCount == 0 ||
        (!seq->f1 && !seq->f2 && !seq->f3)) {
        return DPL_FLOAT32_NAN();
    }
    A = (inst->uwb_dev.config.prf == DWT_PRF_16M) ? DPL_FLOAT32_INIT(113.77f) : DPL_FLOAT32_INIT(121.74f);

#ifdef __KERNEL__
    N = ui32_to_f32(seq->accumCount);
    v = f32_add(f32_add(ui32_to_f32((seq->f1*seq->f1) >> 4),
                        ui32_to_f32((seq->f2*seq->f2) >> 4)),
                ui32_to_f32((seq->f3*seq->f3) >> 4));
    v = f32_div(v, f32_mul(N, N));
    fppl = f32_sub(f32_mul(ui32_to_f32(10), f64_to_f32(log10_soft(f32_to_f64(v)))), A);
#else
    N = seq->accumCount;
    /* f1, f2, and f3 has 2 fractional bits */
    v = (float)((seq->f1*seq->f1) >> 4) + (float)((seq->f2*seq->f2) >> 4);
    v+= (float)((seq->f3*seq->f3) >> 4);
    v /= N*N;
    fppl = 10.0f * log10f(v) - A;
#endif
    return fppl;
}

/**
 * API to calculate First Path Power Level from last RX in dBm,
 * which needs config.rxdiag_enable to be set.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return rssi on success, nan otherwise
 */
dpl_float32_t
dw3000_get_fppl(struct _dw3000_dev_instance_t * inst)
{
    if (!inst->uwb_dev.config.rxdiag_enable) {
        return DPL_FLOAT32_NAN();
    }
    return dw3000_calc_fppl(inst, &inst->rxdiag.ipatov);
}

/**
 * API to calculate rssi from an rxdiag sequence
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 * @param seq  Pointer to struct dw3000_rxdiag_sequence.
 *
 * @return rssi on success, nan otherwise
 */
dpl_float32_t
dw3000_calc_rssi(struct _dw3000_dev_instance_t * inst,
                 struct dw3000_rxdiag_sequence * seq)
{
    dpl_float32_t rssi, A, B;
    if (seq->power == 0 || seq->accumCount == 0) {
        return DPL_FLOAT32_NAN();
    }
    B = (inst->uwb_dev.config.prf == DWT_PRF_16M) ? DPL_FLOAT32_INIT(113.77f) : DPL_FLOAT32_INIT(121.74f);
#ifndef __KERNEL__
    A = seq->power * 0x200000/(seq->accumCount * seq->accumCount);
    rssi = 10.0f * log10f(A) - B;
#else
    A = ui32_to_f32(seq->power * 0x200000);
    A = f32_div(A, ui32_to_f32(seq->accumCount * seq->accumCount));
    A = f32_mul(ui32_to_f32(10), f64_to_f32(log10_soft(f32_to_f64(A))));
    rssi = f32_sub(A, B);
#endif
    return rssi;
}

/**
 * API to calculate rssi from last RX in dBm, which needs config.rxdiag_enable to be set.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return rssi on success, nan otherwise
 */
dpl_float32_t
dw3000_get_rssi(struct _dw3000_dev_instance_t * inst)
{
    if (!inst->uwb_dev.config.rxdiag_enable) {
        return DPL_FLOAT32_NAN();
    }
    return dw3000_calc_rssi(inst, &inst->rxdiag.ipatov);
}

/**
 * API to give a rough estimate of how likely the received packet is
 * line of sight (LOS). Taken from 4.7 of DW3000 manual.
 *
 * @param rssi rssi as calculated by dw3000_calc_rssi
 * @param fppl fppl as calculated by dw3000_calc_fppl
 *
 * @return 1.0 for likely LOS, 0.0 for non-LOS, with a sliding scale in between.
 */
dpl_float32_t
dw3000_estimate_los(dpl_float32_t rssi, dpl_float32_t fppl)
{
    dpl_float32_t d, los;
#ifdef __KERNEL__
    d = soft_abs32(f32_sub(rssi, fppl));
    /* Less than 6dB difference - LOS */
    if (f32_lt(d, DPL_FLOAT32_INIT(6.0f)))  return DPL_FLOAT32_INIT(1.0f);
    /* More than 10dB difference - NLOS */
    if (f32_lt(DPL_FLOAT32_INIT(10.0f), d)) return DPL_FLOAT32_INIT(0.0f);
    /* 1.0 - (d-6)/4.0; */
    los = f32_sub(DPL_FLOAT32_INIT(1.0f),
        f32_div(f32_sub(d, DPL_FLOAT32_INIT(6.0f)), DPL_FLOAT32_INIT(4.0f)));
#else
    d = DPL_FLOAT32_FABS(DPL_FLOAT32_SUB(rssi, fppl));
    /* Less than 6dB difference - LOS */
    if (d < DPL_FLOAT32_INIT(6.0f))  return DPL_FLOAT32_INIT(1.0f);
    /* More than 10dB difference - NLOS */
    if (d > DPL_FLOAT32_INIT(10.0f)) return DPL_FLOAT32_INIT(0.0f);
    /* 1.0 - (d-6)/4.0; */
    los = DPL_FLOAT32_SUB(DPL_FLOAT32_INIT(1.0f),
               DPL_FLOAT32_DIV(d - DPL_FLOAT32_INIT(6.0f),
                               DPL_FLOAT32_INIT(4.0f))
        );
#endif
    return los;
}

/**
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 * @return time (dwt_usecs << 16)
 */
inline uint64_t
dw3000_read_systime(struct _dw3000_dev_instance_t * inst)
{
    /* C0 bug-workaround with internal latching of the value forces us
     * to write somewhere before reading the systime or the value
     * will not update */
    if ((inst->uwb_dev.device_id&DEV_ID_REV_BIT_MASK) < 0x3) {
        dw3000_write_reg(inst, 0, 0, 0, 1);
    }
    return (((uint64_t) dw3000_read_reg(inst, SYS_TIME_ID, 0, 4))<<8) &
        0x0FFFFFFFFFFULL;
}


/**
 * API to read system time at lower offset address.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */
inline uint32_t
dw3000_read_systime_lo(struct _dw3000_dev_instance_t * inst)
{
    uint32_t time = (uint32_t) (dw3000_read_reg(inst, SYS_TIME_ID, 0, 3) << 8);
    if ((inst->uwb_dev.device_id&DEV_ID_REV_BIT_MASK) < 0x2) {
        /* B0 issue with internal latching of the value forces us to read
         * the register twice. */
        time = ((dw3000_read_reg(inst, SYS_TIME_ID, 0, 3))<<8) & 0x0FFFFFFFFFFULL;
    }
    return time;
}

/**
 * API to read the anadjusted(raw) receive time.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */

inline uint64_t
dw3000_read_rawrxtime(struct _dw3000_dev_instance_t * inst)
{
    uint64_t time = ((uint64_t) dw3000_read_reg(inst, RX_TIME_3_ID, 0, RX_TIME_3_LEN) << 8) & 0x0FFFFFFFFFFULL;
    return time;
}

static uint64_t
_read_rxtime(struct _dw3000_dev_instance_t * inst, int len)
{
    uint64_t time;
    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */
        time = dw3000_read_reg(inst, INDIRECT_POINTER_B_ID,
                               BUF1_LATEST_TOA0 - BUF1_FINFO, len);
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        time = dw3000_read_reg(inst, BUF0_LATEST_TOA0, 0, len);
        break;
    default:
        time = dw3000_read_reg(inst, RX_TIME_0_ID, 0, len);
    }

    time &= 0x0FFFFFFFFFFULL;
    return time;
}

/**
 * API to read receive time.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */
uint64_t
dw3000_read_rxtime(struct _dw3000_dev_instance_t * inst)
{
    return _read_rxtime(inst, RX_TIME_RX_STAMP_LEN);
}


/**
 * API to read receive time at lower offset address.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */
inline uint32_t
dw3000_read_rxtime_lo(struct _dw3000_dev_instance_t * inst)
{
    return _read_rxtime(inst, sizeof(uint32_t));
}


/**
 * API to read STS receive time.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time if valid, 0xFFFFFFFFFFFFFFFFULL otherwise
 */
uint64_t
dw3000_read_sts_rxtime(struct _dw3000_dev_instance_t * inst)
{
    uint64_t time;
    const uint64_t err_ret = 0xFFFFFFFFFFFFFFFFULL;

    switch (inst->uwb_dev.status.dblbuff_current) {
    case DBL_BUFF_ACCESS_BUFFER_B:
        /* dw3000_write_reg(inst, INDIRECT_ADDR_B_ID, 0, (BUF1_FINFO >> 16), sizeof(uint32_t)); */
        /* dw3000_write_reg(inst, ADDR_OFFSET_B_ID, 0, BUF1_FINFO&0xffff, sizeof(uint32_t)); */
        time = dw3000_read_reg(inst, INDIRECT_POINTER_B_ID, BUF1_cy0TOA0 - BUF1_FINFO, CIA_C_RX_TIME_LEN);
        break;
    case DBL_BUFF_ACCESS_BUFFER_A:
        time = dw3000_read_reg(inst, BUF1_cy0TOA0, 0, CIA_C_RX_TIME_LEN);
        break;
    default:
        time = dw3000_read_reg(inst, CY0_TOA_LO_ID, 0, CIA_C_RX_TIME_LEN);
    }
    time &= 0x0FFFFFFFFFFULL;

    /* Check sts quality */
    if (inst->rxdiag.sts.accumCount < inst->sts_threshold) {
        return err_ret;
    }
    return time;
}

/**
 * API to read transmission time.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 *
 */
inline uint64_t
dw3000_read_txtime(struct _dw3000_dev_instance_t * inst)
{
    uint64_t time = (uint64_t) dw3000_read_reg(inst, TX_TIME_LO_ID, 0, TX_TIME_TX_STAMP_LEN) & 0x0FFFFFFFFFFULL;
    return time;
}

/**
 * API to read transmit time at lower offset address.
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */
inline uint32_t dw3000_read_txtime_lo(struct _dw3000_dev_instance_t * inst){
    uint32_t time = (uint32_t) dw3000_read_reg(inst, TX_TIME_LO_ID, 0, sizeof(uint32_t));
    return time;
}

/**
 * API to read phase difference of arrival (pdoa)
 *
 * @param inst  Pointer to _dw3000_dev_instance_t.
 *
 * @return time
 */
uint32_t dw3000_read_pdoa(struct _dw3000_dev_instance_t * inst)
{
    // phase difference of the 2 sts POAs (signed in [1:-11])
    uint16_t pdoa = dw3000_read_reg(inst, CIA_TDOA_1_PDOA_ID, 2, sizeof(uint16_t)) & 0x3FFF;
    if (pdoa & 0x2000) pdoa |= 0xC000; //sign extend
    return (int16_t)pdoa;
}

#if 0
/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function will disable TX LDOs and allow TX blocks to be manually turned off by dwt_disable_rftx_blocks
 *
 * input parameters
 * @param[in] switch_config - specifies whether the switch needs to be restored to auto.
 *
 * output parameters
 * None
 *
 */
static void
dwt_disable_rf_tx(struct _dw3000_dev_instance_t * inst, int switch_config)
{
    /* Turn off TX LDOs */
    dw3000_write_reg(inst, LDO_CTRL_ID, 0, 0x00000000, sizeof(uint32_t));

    //Disable RF blocks for TX (configure RF_OVR_ID reg)
    dw3000_write_reg(inst, RF_OVR_ID, 0, 0x00000000, sizeof(uint32_t));

    if (switch_config) {
        //Restore the TXRX switch to auto
        dw3000_write_reg(inst, PDOA_CTRL_ID, 0x0, TXRXSWITCH_AUTO, sizeof(uint32_t));
    }
}
#endif

/*! ------------------------------------------------------------------------------------------------------------------
 * @brief This function will enable TX LDOs and allow TX blocks to be manually turned on by dwt_enable_rftx_blocks for a given channel
 *
 * @param inst            Pointer to _dw3000_dev_instance_t.
 * @param channel         Specifies the operating channel (e.g. 5 or 9)
 * @param switch_control  Specifies whether the switch needs to be configured for TX
 *
 * @return void
 */
static void
dwt_enable_rf_tx(struct _dw3000_dev_instance_t * inst, int channel, int switch_control)
{
    /* Turn on TX LDOs */
    dw3000_modify_reg(inst, LDO_CTRL_ID, 0, 0xffffffff,
                      (LDO_CTRL_LDO_VDDHVTX_VREF_BIT_MASK |
                       LDO_CTRL_LDO_VDDHVTX_EN_BIT_MASK), sizeof(uint32_t));
    dw3000_modify_reg(inst, LDO_CTRL_ID, 0, 0xffffffff,
                      (LDO_CTRL_LDO_VDDTX2_VREF_BIT_MASK |
                       LDO_CTRL_LDO_VDDTX1_VREF_BIT_MASK |
                       LDO_CTRL_LDO_VDDTX2_EN_BIT_MASK |
                       LDO_CTRL_LDO_VDDTX1_EN_BIT_MASK), sizeof(uint32_t));

    //Enable RF blocks for TX (configure RF_OVR_ID reg)
    if (channel == 5) {
        dw3000_modify_reg(inst, RF_OVR_ID, 0, 0xffffffff,
                          (RF_OVR_TX_SW_EN_BIT_MASK
                           | RF_OVR_TX_CH5_BIT_MASK | RF_OVR_TX_EN_BIT_MASK
                           | RF_OVR_TX_EN_BUF_BIT_MASK | RF_OVR_TX_BIAS_EN_BIT_MASK),
                          sizeof(uint32_t));
    } else {
        dw3000_modify_reg(inst, RF_OVR_ID, 0, 0xffffffff,
                          (RF_OVR_TX_SW_EN_BIT_MASK
                           | RF_OVR_TX_EN_BIT_MASK
                           | RF_OVR_TX_EN_BUF_BIT_MASK | RF_OVR_TX_BIAS_EN_BIT_MASK),
                          sizeof(uint32_t));
    }

    if (switch_control) {
        /* configure the TXRX switch for TX mode */
        dw3000_write_reg(inst, PDOA_CTRL_ID, 0x0, TXRXSWITCH_TX, sizeof(uint32_t));
    }

}

/**
 * @brief This function disables the automatic sequencing of the tx-blocks for a specific channel.
 *
 * @param inst            Pointer to _dw3000_dev_instance_t.
 * @param channel         Specifies the operating channel (e.g. 5 or 9)
 *
 * @return void
 */
static void
dwt_enable_rftx_blocks(struct _dw3000_dev_instance_t * inst, int channel)
{
    if (channel == 5) {
        dw3000_modify_reg(inst, RF_CTRL_MASK_ID, 0, 0xffffffff,
                          (RF_OVR_TX_SW_EN_BIT_MASK
                           | RF_OVR_TX_CH5_BIT_MASK | RF_OVR_TX_EN_BIT_MASK
                           | RF_OVR_TX_EN_BUF_BIT_MASK | RF_OVR_TX_BIAS_EN_BIT_MASK),
                          sizeof(uint32_t));
    } else if (channel == 9) {
        dw3000_modify_reg(inst, RF_CTRL_MASK_ID, 0, 0xffffffff,
                          (RF_OVR_TX_SW_EN_BIT_MASK
                           | RF_OVR_TX_EN_BIT_MASK
                           | RF_OVR_TX_EN_BUF_BIT_MASK | RF_OVR_TX_BIAS_EN_BIT_MASK),
                          sizeof(uint32_t));
    }
}


/**
 * @brief This function will enable a repeated continuous waveform on the selected device given a pulse generator
 *        channel and pulse generator coefficient.
 *
 * @param inst                  Pointer to _dw3000_dev_instance_t.
 * @param pulsegen_channel      Channel to use for pulse generation
 * @param pulsegen_coefficient  Coefficient to use for pulse generation.
 *
 * @return void
 */
static void
dwt_repeated_cw(struct _dw3000_dev_instance_t * inst, int pulsegen_channel,
                int pulsegen_coefficient)
{

    /* Turn off TX Seq */
    dw3000_phy_setfinegraintxseq(inst, 0);

    if (pulsegen_coefficient > 0xF)  pulsegen_coefficient = 0xF;
    if ((pulsegen_channel > 3) || (pulsegen_channel < 1)) {
        pulsegen_channel = 4;
    }

    dw3000_write_reg(inst, TX_TEST_ID, 0x0,
                     0x10 >> pulsegen_channel, sizeof(uint32_t));
    dw3000_write_reg(inst, PG_TEST_ID, 0x0,
                     pulsegen_coefficient << ((pulsegen_channel - 1) * 4), sizeof(uint32_t));
}


/**
 * @fn dw3000_configcwmode()
 *
 * @brief this function sets the DW3000 to transmit cw signal at specific channel
 * frequency.
 *
 * @param chan  Specifies the operating channel (e.g. 5, 9)
 *
 * @return void
 */
void
dw3000_configcwmode(struct _dw3000_dev_instance_t * inst, uint8_t chan)
{
    if ((chan != 5) && (chan != 9)) {
        assert(0);
    }

    dwt_enable_rf_tx(inst, chan, 1);
    dwt_enable_rftx_blocks(inst, chan);
    dw3000_phy_force_clocks(inst, FORCE_CLK_SYS_TX);
    dwt_repeated_cw(inst, 1, 0xF);   /* PulseGen Channel 1, full power */
}
